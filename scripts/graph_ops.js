// Generated by CoffeeScript 1.6.1

/*
# -------------------------------------------------------------------------- #
# Center for Environmental Genomics
# Copyright (C) 2012-2013 University of Washington.
#
# Authors:
# Vaughn Iverson
# vsi@uw.edu
# -------------------------------------------------------------------------- #
# This file is part of SEAStAR.
#
# SEAStAR is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SEAStAR is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
# -------------------------------------------------------------------------- #
#
# This script reads in a JSON formatted ref_select output graph and performs
# various transformations on that file.  See the documentation or use the HELP
# command for additional specific information about each transformation.
#
# This script is written in Coffeescript (http://coffeescript.org/) and 
# assumes the node.js (http://nodejs.org/) execution environment. 
#
# It should be run with additional memory allocated for the V8 javascript engine 
# For example:  node --max-old-space-size=4000 --max-new-space-size=4000 ...
# (The included graph_ops (and nodewrap) scripts do this automatically) 
#
# Usage: [<input.json[.gz]>] <command> ['{parms}'] [<command> ['{parms}']...]\n
# 
# Where: <input.json> is an optional datafile to initially LOAD\n
#       <command> is one of the commands listed below\n
#       '{params}' optionally specify parameters for a given command\n
#
# Command list:  (type HELP <command> for more details about a given command):
#
*/


(function() {
  var add_ends, bisect, build_graph_refs, build_removed_graph_refs, calc_ccomps, calc_seq_stats, callback_list, cc_seq_len, check_connections, child_process, clone_object, close_output_stream, cmd, cmds, command_file, commands, cut_branches, cut_node, edge_director, execute_selection, export_dot, export_fasta, export_table, filter_edges, find_all_ends, find_connection, find_direct_connection, find_ends, find_indirect_connection, find_neighbors, fs, full_order, grab_ccomps, grab_clusts, grab_neighbors, graph_stats, graph_stats_cc, heuristic, make_directed, maximal_spanning_tree, my_bisect, my_stringify, node_problems, open_output_stream, output_help, path, perform_edits, pop_stash, prev_cmd, process_commands, push_stash, rc_tab, read_input_stream, read_json, relink, remove_graph_refs, remove_leaves, repl, resolve_path, rev_node, scaff_link, scaffold, scaffold_spanning_tree, ss_version, start_arg, stash_stack, tetracalc, use_heuristic, write_json, zlib, _i, _len, _ref;

  fs = require('fs');

  zlib = require('zlib');

  path = require('path');

  repl = require('repl');

  child_process = require('child_process');

  ss_version = "SS_BUILD_VERSION";

  /*
  # This array stores the stack of json_graph structures used by the (UN)STASH commands
  */


  stash_stack = [];

  /*
  # This function handles a file path that contains '~', resolving it to the user's HOME dir
  */


  resolve_path = function(fn) {
    if (fn[0] === '~') {
      fn = process.env.HOME + fn.slice(1);
    }
    return fn = path.normalize(fn);
  };

  /*
  # Helper function to uniformly handle reading from a file, a gzipped file or stdin
  */


  read_input_stream = function(fn, cb) {
    var input, inputfn, read_buffer;
    if (fn === '-') {
      input = process.stdin;
      input.resume();
    } else {
      inputfn = resolve_path(fn);
      if (inputfn.slice(-3) === '.gz') {
        input = fs.createReadStream(inputfn).pipe(zlib.createGunzip());
      } else {
        input = fs.createReadStream(inputfn);
      }
    }
    read_buffer = '';
    return input.on('data', function(data) {
      return read_buffer = read_buffer.concat(data);
    }).on('end', function() {
      return cb(null, read_buffer);
    }).on('error', function(err) {
      console.error("ERROR: read_input_stream could not open file '" + fn + "' for input.");
      return cb(err, null);
    });
  };

  /*
  # Helper functions to uniformly handle writing to a file, a gzipped file or stdout
  */


  open_output_stream = function(fn) {
    var fout, gz, inc, out, renumber;
    if (fn) {
      fn = resolve_path(fn);
      if (renumber = fn.match(/([^#]*)(#+)([^#]*)/)) {
        inc = 0;
        renumber[2] = renumber[2].replace(/#/g, '0');
        fn = renumber[1] + renumber[2].slice(inc.toString().length) + inc.toString() + renumber[3];
        while (fs.existsSync(fn)) {
          inc++;
          fn = renumber[1] + renumber[2].slice(inc.toString().length) + inc.toString() + renumber[3];
        }
        console.warn("INFO: Opening numbered file " + fn);
      } else if (fs.existsSync(fn)) {
        console.warn("WARNING: Overwriting file " + fn);
      }
      fout = fs.createWriteStream(fn);
      if (fout) {
        if (fn.slice(-3) === '.gz') {
          gz = zlib.createGzip();
          gz.pipe(fout);
          out = gz;
        } else {
          out = fout;
        }
      } else {
        out = null;
      }
    } else {
      out = process.stdout;
    }
    return out;
  };

  /*
  # This file must be called to close the stream opened by the function above
  */


  close_output_stream = function(out, cb) {
    if (!((out === process.stdout) || (out === process.stderr))) {
      out.on("error", function(err) {
        return cb(err);
      });
      out.on("close", function() {
        return cb(null);
      });
      out.on("end", function() {
        return cb(null);
      });
      return out.end();
    } else {
      return cb(null);
    }
  };

  my_stringify = function(j, o, l) {
    var first, name, obj, _i, _len;
    if (l == null) {
      l = 1;
    }
    if (l && (j instanceof Array)) {
      o.write("[");
      first = true;
      for (_i = 0, _len = j.length; _i < _len; _i++) {
        obj = j[_i];
        if (!first) {
          o.write(",\n");
        }
        first = false;
        my_stringify(obj, o, l - 1);
      }
      return o.write("]");
    } else if (l && (typeof j === 'object')) {
      o.write("{");
      first = true;
      for (name in j) {
        obj = j[name];
        if (!first) {
          o.write(",\n");
        }
        first = false;
        o.write("\"" + name + "\":");
        my_stringify(obj, o, l - 1);
      }
      return o.write("}");
    } else {
      return o.write(JSON.stringify(j));
    }
  };

  clone_object = function(obj) {
    var clone, i;
    clone = obj instanceof Array ? [] : {};
    for (i in obj) {
      if (typeof obj[i] === "object") {
        clone[i] = clone_object(obj[i]);
      } else {
        clone[i] = obj[i];
      }
    }
    return clone;
  };

  /*
  # Calc_seq_stats calculates the N50, mean %gc and coverage and contig length statistic 
  # for the nodes in the passed-in object. It also returns the total length of all sequences
  */


  calc_seq_stats = function(nodes) {
    var cov, gc, l, n, name, running_total, seq_list, seq_total, _i, _len, _ref;
    seq_total = 0;
    seq_list = [];
    cov = 0.0;
    gc = 0.0;
    for (name in nodes) {
      n = nodes[name];
      seq_total += n.seq_len;
      cov += n.cov * n.seq_len;
      gc += ((_ref = n.pct_gc) != null ? _ref : 0) * n.seq_len;
      seq_list.push(n);
    }
    seq_list.sort(function(a, b) {
      return b.seq_len - a.seq_len;
    });
    running_total = 0;
    for (_i = 0, _len = seq_list.length; _i < _len; _i++) {
      l = seq_list[_i];
      running_total += l.seq_len;
      if (running_total >= seq_total / 2) {
        break;
      }
    }
    return [l.seq_len, seq_total, cov / seq_total, gc / seq_total, seq_list[0].name];
  };

  /*
  # cc_seq_len calculates the total sequence length for all nodes in the provided cc
  */


  cc_seq_len = function(j, cc) {
    var nid, sum_len, _i, _len;
    sum_len = 0;
    for (_i = 0, _len = cc.length; _i < _len; _i++) {
      nid = cc[_i];
      sum_len += j.nodes[nid].seq_len;
    }
    return sum_len;
  };

  /*
  # Bisect returns a function that when called with an accessor function f,
  # returns a function that takes an array a and a value x, and returns the
  # position in the array where x should be inserted (assuming an ascending 
  # sorted array).
  */


  bisect = function(f) {
    return function(a, x, lo, hi) {
      var mid;
      if (arguments.length < 3) {
        lo = 0;
      }
      if (arguments.length < 4) {
        hi = a.length;
      }
      while (lo < hi) {
        mid = lo + hi >> 1;
        if (x < f.call(a, a[mid], mid)) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return lo;
    };
  };

  /*
  # my_bisect is a function to efficiently find a position in an array of elements sorted by score
  */


  my_bisect = bisect(function(d) {
    return d[0].score;
  });

  /*
  # heuristic scoring function that biases bitscores toward edges that connect
  # nodes with similar GC% and Coverage. (Mostly for metagenome assembly)
  */


  use_heuristic = true;

  heuristic = function(a_gc, b_gc, a_cov, b_cov) {
    return (0.08 * Math.abs(a_gc - b_gc)) + (0.125 * Math.abs(Math.log(a_cov, 2) - Math.log(b_cov, 2)));
  };

  /*
  # Setup the internal references between nodes and edges in the graph 
  # This function is necessary because the JSON representation of the assembly graph 
  # cannot contain any references between sub-objects of the datastructure
  */


  build_graph_refs = function(j, nf, ef) {
    var e, e_out, i, l_in, l_out, n, n_out, name, s_gc, t_gc, _i, _len;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    n_out = (function() {
      var _ref, _results;
      _ref = j.nodes;
      _results = [];
      for (name in _ref) {
        n = _ref[name];
        n.id = name;
        n.inlinks = [];
        n.outlinks = [];
        n.links = [];
        if (typeof nf === "function") {
          nf(n);
        }
        _results.push(n);
      }
      return _results;
    })();
    e_out = (function() {
      var _i, _len, _ref, _results;
      _ref = j.edges;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        e = _ref[i];
        if (!(e.src = j.nodes[e.n1])) {
          throw "build_graph_refs: Missing node " + e.n1 + " in edge with " + e.n2 + ".";
        }
        if (!(e.tar = j.nodes[e.n2])) {
          throw "build_graph_refs: Missing node " + e.n2 + " in edge with " + e.n1 + ".";
        }
        if (e.score == null) {
          e.score = e.bits;
          if (use_heuristic) {
            if ((e.src.pct_gc != null) && (e.tar.pct_gc != null)) {
              s_gc = e.src.pct_gc;
              t_gc = e.tar.pct_gc;
            } else {
              s_gc = 0;
              t_gc = 0;
            }
            e.score -= e.bits * heuristic(s_gc, t_gc, e.src.cov, e.tar.cov);
          }
        }
        e.index = i;
        _results.push(e);
      }
      return _results;
    })();
    e_out.sort(function(a, b) {
      return b.score - a.score;
    });
    for (_i = 0, _len = e_out.length; _i < _len; _i++) {
      e = e_out[_i];
      l_out = [e, e.tar];
      e.src.outlinks.push(l_out);
      e.src.links.push(l_out);
      l_in = [e, e.src];
      e.tar.inlinks.push(l_in);
      e.tar.links.push(l_in);
      if (typeof ef === "function") {
        ef(e);
      }
    }
    return [n_out, e_out];
  };

  /*
  # Setup the internal references between removed nodes and edges in the graph 
  # Similar to build_graph_refs above, but works on the "removed" pool of nodes and edges
  # Including connecting them to "selected" nodes
  */


  build_removed_graph_refs = function(j, nf, ef) {
    var e, e_out, i, l_in, l_out, n, n_out, name, s_gc, t_gc, _i, _len, _ref, _ref1, _ref2;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    if ((_ref = j.removed_nodes) == null) {
      j.removed_nodes = {};
    }
    if ((_ref1 = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    _ref2 = j.nodes;
    for (name in _ref2) {
      n = _ref2[name];
      n.rem_inlinks = [];
      n.rem_outlinks = [];
      n.rem_links = [];
      if (typeof nf === "function") {
        nf(n);
      }
    }
    n_out = (function() {
      var _ref3, _results;
      _ref3 = j.removed_nodes;
      _results = [];
      for (name in _ref3) {
        n = _ref3[name];
        n.id = name;
        n.rem_inlinks = [];
        n.rem_outlinks = [];
        n.rem_links = [];
        if (typeof nf === "function") {
          nf(n);
        }
        _results.push(n);
      }
      return _results;
    })();
    e_out = (function() {
      var _i, _len, _ref3, _results;
      _ref3 = j.removed_edges;
      _results = [];
      for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
        e = _ref3[i];
        if (!(e.src = j.nodes[e.n1] || j.removed_nodes[e.n1])) {
          throw "build_removed_graph_refs: Missing node " + e.n1 + " in removed edge with " + e.n2 + ".";
        }
        if (!(e.tar = j.nodes[e.n2] || j.removed_nodes[e.n2])) {
          throw "build_removed_graph_refs: Missing node " + e.n2 + " in removed edge with " + e.n1 + ".";
        }
        if (e.score == null) {
          e.score = e.bits;
          if (use_heuristic) {
            if ((e.src.pct_gc != null) && (e.tar.pct_gc != null)) {
              s_gc = e.src.pct_gc;
              t_gc = e.tar.pct_gc;
            } else {
              s_gc = 0;
              t_gc = 0;
            }
            e.score -= e.bits * heuristic(s_gc, t_gc, e.src.cov, e.tar.cov);
          }
        }
        e.index = i;
        _results.push(e);
      }
      return _results;
    })();
    e_out.sort(function(a, b) {
      return b.score - a.score;
    });
    for (_i = 0, _len = e_out.length; _i < _len; _i++) {
      e = e_out[_i];
      l_out = [e, e.tar];
      e.src.rem_outlinks.push(l_out);
      e.src.rem_links.push(l_out);
      l_in = [e, e.src];
      e.tar.rem_inlinks.push(l_in);
      e.tar.rem_links.push(l_in);
      if (typeof ef === "function") {
        ef(e);
      }
    }
    return [n_out, e_out];
  };

  /*   
  # Remove the internal references between nodes and edges in the graph 
  # This undoes all of the linking performed by the "build" functions above, leaving the 
  # graph datastructure in a state that can be serialized into JSON
  # This function removes references for both selected and removed nodes
  */


  remove_graph_refs = function(j, nf, ef) {
    var e, n, name, _ref, _ref1;
    if (nf == null) {
      nf = null;
    }
    if (ef == null) {
      ef = null;
    }
    _ref = j.nodes;
    for (name in _ref) {
      n = _ref[name];
      delete n.id;
      delete n.links;
      delete n.inlinks;
      delete n.outlinks;
      delete n.rem_links;
      delete n.rem_inlinks;
      delete n.rem_outlinks;
      if (typeof nf === "function") {
        nf(n);
      }
    }
    j.edges = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = j.edges;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        e = _ref1[_i];
        if (!(e != null)) {
          continue;
        }
        delete e.src;
        delete e.tar;
        delete e.index;
        if (typeof ef === "function") {
          ef(e);
        }
        _results.push(e);
      }
      return _results;
    })();
    if (j.removed_nodes != null) {
      _ref1 = j.removed_nodes;
      for (name in _ref1) {
        n = _ref1[name];
        delete n.id;
        delete n.links;
        delete n.inlinks;
        delete n.outlinks;
        delete n.rem_links;
        delete n.rem_inlinks;
        delete n.rem_outlinks;
        if (typeof nf === "function") {
          nf(n);
        }
      }
    }
    if (j.removed_edges != null) {
      return j.removed_edges = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = j.removed_edges;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          e = _ref2[_i];
          if (!(e != null)) {
            continue;
          }
          delete e.src;
          delete e.tar;
          delete e.index;
          if (typeof ef === "function") {
            ef(e);
          }
          _results.push(e);
        }
        return _results;
      })();
    }
  };

  /*
  # Calculate the current set of connected components
  */


  calc_ccomps = function(j, args, callback) {
    var edge_cand, l, n, node, nodes, nodes_added, nodes_avail, _i, _j, _len, _len1, _ref, _ref1;
    if (args == null) {
      args = {
        "sortby": "nodes"
      };
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Calculate the current graph connected components");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nsortby : <string> -- Specify how to sort the resulting list of CCs.  \"nodes\" or \"sequences\"\n\n        Example: " + args.help + " {\"sortby\":\"nodes\"} -- Default. Sort CCs in descending\n        order of number of nodes.\n\n        Example: " + args.help + " {\"sortby\":\"sequences\"} -- Sort CCs in descending order\n        of amount of sequence.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.scaffolds != null) {
      console.warn("WARNING: Previous operation changed connected component structure, so existing scaffolds and clusters are being removed.\n");
      delete j.scaffolds;
      if (j.clusters != null) {
        delete j.clusters;
      }
    }
    if ((_ref = j.removed_nodes) == null) {
      j.removed_nodes = {};
    }
    if ((args.sortby != null) && ["nodes", "sequences"].indexOf(args.sortby) === -1) {
      if (typeof callback === "function") {
        callback(new Error('sortby argument must equal either "nodes" or "sequences".'), null);
      }
      return;
    }
    try {
      nodes = build_graph_refs(j)[0];
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    j.connected_comps = [];
    nodes_avail = {};
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      nodes_avail[node.id] = node;
    }
    n = nodes[0];
    edge_cand = [];
    nodes_added = [];
    while (n) {
      delete nodes_avail[n.id];
      nodes_added.push(n.id);
      _ref1 = n.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        l = _ref1[_j];
        if (nodes_avail[l[1].id] != null) {
          edge_cand.push(l);
        }
      }
      l = edge_cand.pop();
      while (l && (nodes_avail[l[1].id] == null)) {
        l = edge_cand.pop();
      }
      if (l) {
        n = l[1];
      } else {
        nodes_added.sort(function(a, b) {
          return j.nodes[b].seq_len - j.nodes[a].seq_len;
        });
        j.connected_comps.push(nodes_added);
        nodes_added = [];
        n = nodes.pop();
        while (n && (nodes_avail[n.id] == null)) {
          n = nodes.pop();
        }
      }
    }
    remove_graph_refs(j);
    if (args.sortby === "sequences") {
      j.connected_comps.sort(function(a, b) {
        return cc_seq_len(j, b) - cc_seq_len(j, a);
      });
    } else {
      j.connected_comps.sort(function(a, b) {
        return b.length - a.length;
      });
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  ## Used to sort out the various types of MP edges and how they orient the underlying contigs
  */


  edge_director = function(prev_n, n, e) {
    var _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (e.dir === "forward") {
      return e;
    }
    e.org_dir = e.dir;
    e.p1 = Math.abs(e.p1);
    e.p2 = Math.abs(e.p2);
    switch ([e.dir, prev_n.ref_str, e.n2 === n.id].join("_")) {
      case "FB_true_true":
      case "FB_true_false":
        if ((n.ref_str == null) || n.ref_str) {
          n.ref_str = true;
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FB_false_true":
      case "FB_false_false":
        if ((n.ref_str == null) || !n.ref_str) {
          n.ref_str = false;
          _ref = [e.tar.seq_len - e.p2 - 1, e.src.seq_len - e.p1 - 1], e.p1 = _ref[0], e.p2 = _ref[1];
          _ref1 = [e.n2, e.n1], e.n1 = _ref1[0], e.n2 = _ref1[1];
          _ref2 = [e.tar, e.src], e.src = _ref2[0], e.tar = _ref2[1];
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FF_true_true":
      case "FF_false_false":
      case "BB_true_false":
      case "BB_false_true":
        if ((n.ref_str == null) || n.ref_str === !prev_n.ref_str) {
          n.ref_str = !prev_n.ref_str;
          if (prev_n.ref_str ^ (e.n2 === n.id)) {
            e.p1 = e.src.seq_len - e.p1 - 1;
          } else {
            e.p2 = e.tar.seq_len - e.p2 - 1;
          }
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      case "FF_true_false":
      case "FF_false_true":
      case "BB_true_true":
      case "BB_false_false":
        if ((n.ref_str == null) || n.ref_str === !prev_n.ref_str) {
          n.ref_str = !prev_n.ref_str;
          if (prev_n.ref_str ^ (e.n2 === n.id)) {
            e.p1 = e.src.seq_len - e.p1 - 1;
          } else {
            e.p2 = e.tar.seq_len - e.p2 - 1;
          }
          _ref3 = [e.p2, e.p1], e.p1 = _ref3[0], e.p2 = _ref3[1];
          _ref4 = [e.n2, e.n1], e.n1 = _ref4[0], e.n2 = _ref4[1];
          _ref5 = [e.tar, e.src], e.src = _ref5[0], e.tar = _ref5[1];
          e.dir = "forward";
          return e;
        } else {
          return null;
        }
        break;
      default:
        return null;
    }
  };

  /*
  # rev_node - Reverse a node's sequence (mate-pair positions are handled by edge_director)
  */


  rc_tab = {
    'A': 'T',
    'T': 'A',
    'G': 'C',
    'C': 'G',
    'X': 'X',
    'M': 'K',
    'K': 'M',
    'R': 'Y',
    'Y': 'R',
    'W': 'S',
    'S': 'W',
    'V': 'B',
    'B': 'V',
    'H': 'D',
    'D': 'H',
    'N': 'N'
  };

  rev_node = function(n) {
    if (!(n.ref_str || (n.recon_seq == null))) {
      return n.recon_seq = n.recon_seq.toUpperCase().split("").reverse().map(function(b) {
        return rc_tab[b];
      }).join("");
    }
  };

  /*
  # Make each connected component a directed graph, properly orienting the 
  # nodes relative to each other
  */


  make_directed = function(j) {
    var cc, ccnodes, e, edge_cand, l, max_len, max_node, n, nid, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    _ref = j.connected_comps;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cc = _ref[_i];
      ccnodes = {};
      edge_cand = [];
      max_len = 0;
      max_node = null;
      for (_j = 0, _len1 = cc.length; _j < _len1; _j++) {
        nid = cc[_j];
        n = j.nodes[nid];
        ccnodes[nid] = n;
        if (n.seq_len > max_len) {
          max_node = n;
          max_len = n.seq_len;
        }
      }
      n = max_node;
      n.ref_str = true;
      while (n) {
        delete ccnodes[n.id];
        _ref1 = n.links;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          l = _ref1[_k];
          if (!(ccnodes[l[1].id] != null)) {
            continue;
          }
          l.push(n);
          edge_cand.unshift(l);
        }
        l = edge_cand.pop();
        n = null;
        if (l) {
          if (!ccnodes[l[1].id]) {
            throw "make_directed: Cycle detected at node: " + l[1].id;
          }
          n = l[1];
          if (!(e = edge_director(l[2], n, l[0]))) {
            throw "make_directed: Improper edge type " + e.dir + " detected between nodes: " + n.id + " and " + l[2].id;
          }
          rev_node(n);
        }
      }
    }
    j.digraph = true;
    return remove_graph_refs(j);
  };

  /*
  ## Spanning tree processing using Primm's algorithm
  */


  maximal_spanning_tree = function(j, args, callback) {
    var c, edge_cand, edges_added, l, links, n, new_link, next_n, nodes, nodes_added, nodes_seen, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Calculate the Maximal Spanning Tree of all connected components");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nbits : true -- Use raw connection bitscores and not GC% / Coverage adjusted bitscores\n\n        Example: " + args.help + " {\"bits\":true} -- Use raw connection bitscores from mate-pairing\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.bits) {
      use_heuristic = false;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    if ((_ref = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    try {
      _ref1 = build_graph_refs(j), nodes = _ref1[0], links = _ref1[1];
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    edges_added = [];
    _ref2 = j.connected_comps;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      c = _ref2[_i];
      n = j.nodes[c[0]];
      nodes_added = {};
      nodes_added[n.id] = n;
      nodes_seen = {};
      edge_cand = [];
      while (n) {
        if (n.contig_problems != null) {
          console.warn("Warning: Contig " + n.id + " has " + n.contig_problems.length + " internal coverage problem(s) and is likely misassembled.  Problem: " + n.contig_problems[0].type + " detected");
        }
        _ref3 = n.links;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          l = _ref3[_j];
          if (nodes_added[l[1].id] == null) {
            edge_cand.splice(my_bisect(edge_cand, l[0].score), 0, l);
          } else if (l[0].done == null) {
            l[0].done = true;
            j.removed_edges.push(l[0]);
          }
        }
        next_n = edge_cand.pop();
        while (next_n && (nodes_added[next_n[1].id] != null)) {
          if (next_n[0].done == null) {
            next_n[0].done = true;
            j.removed_edges.push(next_n[0]);
          }
          next_n = edge_cand.pop();
        }
        if (next_n) {
          new_link = next_n[0], n = next_n[1];
          nodes_added[n.id] = n;
          edges_added.push(new_link);
          new_link.done = true;
        } else {
          n = null;
        }
      }
    }
    j.edges = edges_added;
    remove_graph_refs(j, null, (function(ed) {
      return delete ed.done;
    }));
    try {
      make_directed(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Scaffolding spanning tree processing, strives to minimize parallel branches when 
  # nodes are short relative to pairing insert size
  */


  scaffold_spanning_tree = function(j, args, callback) {
    var c, e, edge_cand, edges_added, l, links, n, new_link, new_territory, next_n, nodes, nodes_added, nodes_seen, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Calculate the improved Scaffold Spanning Tree of all connected components");
      if (args.detailed_help != null) {
        console.warn("\n        NOTE: This command is generally preferable to the MST command when median contig\n        length is less than the mean distance between paired reads. That is, when a\n        relatively large insert size was selected.\n \nParameters:\n\nbits : true -- Use raw connection bitscores and not GC% / Coverage adjusted bitscores\n\n        Example: " + args.help + " {\"bits\":true} -- Use raw connection bitscores from mate-pairing\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.bits) {
      use_heuristic = false;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    if ((_ref = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    try {
      _ref1 = build_graph_refs(j, function(n) {
        return n.int_mp_bits = 0.0;
      }), nodes = _ref1[0], links = _ref1[1];
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    _ref2 = j.internal_edges;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      e = _ref2[_i];
      if (j.nodes[e.n1] != null) {
        j.nodes[e.n1].int_mp_bits = e.bits;
      }
    }
    new_territory = function(node) {
      var l, next_l, _j, _len1, _ref3;
      next_l = null;
      _ref3 = node.links;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        l = _ref3[_j];
        if ((nodes_added[l[1].id] == null) && ((nodes_seen[l[1].id] == null) || (l[1].int_mp_bits / l[1].links[0][0].bits > 0.02))) {
          next_l = l;
          break;
        }
      }
      return next_l;
    };
    edges_added = [];
    _ref3 = j.connected_comps;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      c = _ref3[_j];
      n = j.nodes[c[0]];
      nodes_added = {};
      nodes_added[n.id] = n;
      nodes_seen = {};
      edge_cand = [];
      next_n = true;
      while (next_n) {
        next_n = null;
        new_link = null;
        if (n) {
          _ref4 = n.links;
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            l = _ref4[_k];
            if ((nodes_added[l[1].id] == null) && (!(nodes_seen[l[1].id] != null) || (l[0].score > nodes_seen[l[1].id][0].score))) {
              nodes_seen[l[1].id] = l;
              edge_cand.splice(my_bisect(edge_cand, l[0].score), 0, l);
            } else if (l[0].done == null) {
              l[0].done = true;
              j.removed_edges.push(l[0]);
            }
          }
        }
        next_n = edge_cand.pop();
        while (next_n && (nodes_added[next_n[1].id] != null)) {
          if (next_n[0].done == null) {
            next_n[0].done = true;
            j.removed_edges.push(next_n[0]);
          }
          next_n = edge_cand.pop();
        }
        if (next_n) {
          new_link = next_n[0], n = next_n[1];
          if (n.contig_problems != null) {
            console.warn("Warning: Contig " + n.id + " has " + n.contig_problems.length + " internal coverage problem(s) and is likely misassembled.  Problem: " + n.contig_problems[0].type + " detected");
          }
          nodes_added[n.id] = n;
          edges_added.push(new_link);
          new_link.done = true;
          if (!new_territory(n)) {
            _ref5 = n.links;
            for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
              l = _ref5[_l];
              if (l[0].done == null) {
                l[0].done = true;
                j.removed_edges.push(l[0]);
              }
            }
            n = null;
          }
        }
      }
    }
    j.edges = edges_added;
    remove_graph_refs(j, (function(nd) {
      return delete nd.int_mp_bits;
    }), (function(ed) {
      return delete ed.done;
    }));
    try {
      make_directed(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Pluck leaves off the tree, the purpose is to remove short branches before pruning
  # to avoid unnecessarily splintering the tree into thousands of branches shorter than
  # the mean pairing insert length
  */


  remove_leaves = function(j, args, callback) {
    var e, edges, edges_kept, i, n, nodes, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Remove all leaf contig nodes (in or outdegree == 0) from the graph");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\niterate : <int> -- number of iterations of " + args.help + " to run. Each is equivalent to\n       running " + args.help + " again as a separate command.  By Default <int> = 2\n\n        Example: " + args.help + " {\"iterate\":2} -- Equivalent of " + args.help + " " + args.help + "\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.iterate) == null) {
      args.iterate = 2;
    }
    delete j.connected_comps;
    if ((_ref1 = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    if ((_ref2 = j.removed_nodes) == null) {
      j.removed_nodes = {};
    }
    for (i = _i = 1, _ref3 = args.iterate; 1 <= _ref3 ? _i <= _ref3 : _i >= _ref3; i = 1 <= _ref3 ? ++_i : --_i) {
      try {
        _ref4 = build_graph_refs(j), nodes = _ref4[0], edges = _ref4[1];
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      for (_j = 0, _len = nodes.length; _j < _len; _j++) {
        n = nodes[_j];
        if (!(n.inlinks.length === 0 || n.outlinks.length === 0)) {
          continue;
        }
        j.removed_nodes[n.id] = n;
        delete j.nodes[n.id];
      }
      edges_kept = [];
      for (_k = 0, _len1 = edges.length; _k < _len1; _k++) {
        e = edges[_k];
        if ((j.nodes[e.n1] != null) && (j.nodes[e.n2] != null)) {
          edges_kept.push(e);
        } else {
          e.pluck_iteration = i;
          j.removed_edges.push(e);
        }
      }
      j.edges = edges_kept;
      remove_graph_refs(j);
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  ## prune the tree by cutting off branches
  */


  cut_branches = function(j, args, callback) {
    var e, edges, edges_kept, in_ratio, l, n, nodes, out_ratio, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Split the assembly graph at all contig nodes with in or out degree > 1");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nstrict : true -- always cut all but the strongest link when there are > 2 in+out links\n\n        Example: " + args.help + " {\"strict\":false} -- The default case, attempt to determine\n        which branch(es) to remove to preserve one high weight path across a multiply\n        linked contig node.\n\n        Example: " + args.help + " {\"strict\":true} -- Always strictly prune. Equivalent to\n        {\"ratio\":0.0} below\n\nratio : <float> -- ratio of the strongest to next strongest links to trigger strict pruning\n\n        Example: " + args.help + " {\"ratio\":0.0} -- Always strictly prune.\n\n        Example: " + args.help + " {\"ratio\":1.0} -- Never strictly prune.\n\n        Example: " + args.help + " {\"ratio\":0.2} -- Default. Don't strictly filter when the\n        score of the highest scoring edge is >= 5x greater than the next highest scoring\n        link of the same direction (for both in and outlinks)\n\nverbose : true -- output diagnostics on STDERR\n\n        Example: " + args.help + " {\"verbose\":true} -- Generate extra output information\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.strict) == null) {
      args.strict = false;
    }
    if ((_ref1 = args.ratio) == null) {
      args.ratio = 0.2;
    }
    delete j.connected_comps;
    if ((_ref2 = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    try {
      _ref3 = build_graph_refs(j), nodes = _ref3[0], edges = _ref3[1];
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    edges_kept = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      n = nodes[_i];
      if (n.inlinks.length > 1) {
        in_ratio = (n.inlinks[1][0].score / n.inlinks[0][0].score) > args.ratio;
        if (args.verbose) {
          console.warn("Inlinks: " + n.name + " " + n.inlinks.length + " " + (n.inlinks[1][0].score / n.inlinks[0][0].score) + " " + in_ratio);
        }
        _ref4 = n.inlinks.slice(1);
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          l = _ref4[_j];
          l[0].remove = true;
        }
      } else {
        in_ratio = false;
      }
      if (n.outlinks.length > 1) {
        out_ratio = (n.outlinks[1][0].score / n.outlinks[0][0].score) > args.ratio;
        if (args.verbose) {
          console.warn("Outlinks: " + n.name + " " + n.outlinks.length + " " + (n.outlinks[1][0].score / n.outlinks[0][0].score) + " " + out_ratio);
        }
        _ref5 = n.outlinks.slice(1);
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          l = _ref5[_k];
          l[0].remove = true;
        }
      } else {
        out_ratio = false;
      }
      if (args.strict && n.inlinks.length && n.outlinks.length && (n.inlinks.length + n.outlinks.length > 2) && (in_ratio || out_ratio)) {
        n.no_push = true;
        if (n.inlinks[0][0].score > n.outlinks[0][0].score) {
          n.outlinks[0][0].remove = true;
          console.warn("Strictly Removing " + n.outlinks[0][0].n1 + " --> " + n.outlinks[0][0].n2);
        } else {
          n.inlinks[0][0].remove = true;
          console.warn("Strictly Removing " + n.inlinks[0][0].n1 + " --> " + n.inlinks[0][0].n2);
        }
      }
    }
    for (_l = 0, _len3 = edges.length; _l < _len3; _l++) {
      e = edges[_l];
      if (e.remove != null) {
        j.removed_edges.push(e);
        delete e.remove;
      } else {
        edges_kept.push(e);
      }
    }
    j.edges = edges_kept;
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  ## Returns the nodes at the beginning and end of a linear scaffold chain [head, tail] by ccomp
  */


  find_ends = function(j, ccomp, strict) {
    var cn, head_nodes, tail_nodes, _i, _len;
    if (strict == null) {
      strict = false;
    }
    head_nodes = [];
    tail_nodes = [];
    for (_i = 0, _len = ccomp.length; _i < _len; _i++) {
      cn = ccomp[_i];
      if (j.nodes[cn].inlinks.length === 0) {
        head_nodes.push(j.nodes[cn]);
      }
      if (j.nodes[cn].outlinks.length === 0) {
        tail_nodes.push(j.nodes[cn]);
      }
    }
    if (strict && (head_nodes.length !== 1 || tail_nodes.length !== 1)) {
      throw "find_ends: multiple head/tail nodes found in scaffolded CC. SLICE must be run before use of this command.";
    }
    return [head_nodes, tail_nodes];
  };

  /*
  ## Returns [head, tail] lists from find_ends() above for all connected components
  ## calculates temporary maximal_spanning_tree() to produce this information, but
  ## restores the global state when done
  */


  find_all_ends = function(j) {
    var c, output_list;
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    output_list = (function() {
      var _i, _len, _ref, _results;
      _ref = j.connected_comps;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(find_ends(j, c));
      }
      return _results;
    })();
    remove_graph_refs(j);
    return output_list;
  };

  /*
  # heuristically remove edges in a linear ccomp that span coverage and/or GC 
  # discontinuities
  */


  check_connections = function(j, args, callback) {
    var c, cedges, cnodes, cov_down, cov_up, edge_heuristics, edges_kept, eh, gc_down, gc_up, head_node, i, l, len_down, len_up, max_edge_idx, max_heur, n, split, tot, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Break linear scaffolds at a GC / coverage discontinuity");
      if (args.detailed_help != null) {
        console.warn("\n        NOTE: Each run of " + args.help + " will break a given scaffold at no more than one\n        position. " + args.help + " should be run multiple times if multiple misassemblies\n        are suspected.\n\nParameters:\n\nthresh : <float> -- Threshold used to determine whether or not to break a connection\n\n        Example: " + args.help + " '{\"thresh\":0.5}' -- Default. Medium strength heuristic\n         score based on GC% / Coverage statistics of a scaffold on either side of a given\n        contigs connection edge. The lower the threshold, the more sensitive the filter\n        is to such discontinuities.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.thresh) == null) {
      args.thresh = 0.5;
    }
    split = true;
    while (split) {
      split = false;
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      if ((_ref1 = j.removed_edges) == null) {
        j.removed_edges = [];
      }
      edges_kept = [];
      try {
        build_graph_refs(j);
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      _ref2 = j.connected_comps;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        c = _ref2[_i];
        try {
          head_node = find_ends(j, c, true)[0][0];
        } catch (err) {
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        l = head_node.outlinks[0];
        cnodes = [head_node];
        cedges = [];
        while (l) {
          cnodes.push(l[1]);
          cedges.push(l[0]);
          l = l[1].outlinks[0];
        }
        tot = 0.0;
        len_up = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = cnodes.length; _j < _len1; _j++) {
            n = cnodes[_j];
            _results.push(tot += n.seq_len);
          }
          return _results;
        })();
        tot = 0.0;
        gc_up = (function() {
          var _j, _len1, _ref3, _results;
          _results = [];
          for (i = _j = 0, _len1 = cnodes.length; _j < _len1; i = ++_j) {
            n = cnodes[i];
            _results.push((tot += ((_ref3 = n.pct_gc) != null ? _ref3 : 0) * n.seq_len) / len_up[i]);
          }
          return _results;
        })();
        tot = 0.0;
        cov_up = (function() {
          var _j, _len1, _results;
          _results = [];
          for (i = _j = 0, _len1 = cnodes.length; _j < _len1; i = ++_j) {
            n = cnodes[i];
            _results.push((tot += n.cov * n.seq_len) / len_up[i]);
          }
          return _results;
        })();
        cnodes.reverse();
        tot = 0.0;
        len_down = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = cnodes.length; _j < _len1; _j++) {
            n = cnodes[_j];
            _results.push(tot += n.seq_len);
          }
          return _results;
        })();
        tot = 0.0;
        gc_down = (function() {
          var _j, _len1, _ref3, _results;
          _results = [];
          for (i = _j = 0, _len1 = cnodes.length; _j < _len1; i = ++_j) {
            n = cnodes[i];
            _results.push((tot += ((_ref3 = n.pct_gc) != null ? _ref3 : 0) * n.seq_len) / len_down[i]);
          }
          return _results;
        })();
        tot = 0.0;
        cov_down = (function() {
          var _j, _len1, _results;
          _results = [];
          for (i = _j = 0, _len1 = cnodes.length; _j < _len1; i = ++_j) {
            n = cnodes[i];
            _results.push((tot += n.cov * n.seq_len) / len_down[i]);
          }
          return _results;
        })();
        gc_down.reverse();
        cov_down.reverse();
        edge_heuristics = (function() {
          var _j, _ref3, _results;
          _results = [];
          for (i = _j = 0, _ref3 = cedges.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
            _results.push(heuristic(gc_up[i], gc_down[i + 1], cov_up[i], cov_down[i + 1]));
          }
          return _results;
        })();
        max_edge_idx = -1;
        max_heur = -1;
        for (i = _j = 0, _len1 = edge_heuristics.length; _j < _len1; i = ++_j) {
          eh = edge_heuristics[i];
          if (!(eh > max_heur)) {
            continue;
          }
          max_heur = eh;
          max_edge_idx = i;
        }
        if (max_heur > args.thresh) {
          split = true;
          j.removed_edges.push(cedges.splice(max_edge_idx, 1)[0]);
        }
        edges_kept = edges_kept.concat(cedges);
      }
      j.edges = edges_kept;
      remove_graph_refs(j);
      delete j.connected_comps;
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  ## filter edges from the graph by bitscore
  */


  filter_edges = function(j, args, callback) {
    var e, edges_kept, _i, _len, _ref, _ref1, _ref2;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Remove all edges scoring less than thresh bits");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nthresh : <float> -- Bitscore threshold\n\n        Example: " + args.help + " {\"thresh\":500.0}' -- Default. Remove all edges scoring\n        less than 500.0 bits.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.thresh) == null) {
      args.thresh = 500.0;
    }
    delete j.connected_comps;
    if ((_ref1 = j.removed_edges) == null) {
      j.removed_edges = [];
    }
    edges_kept = [];
    _ref2 = j.edges;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      e = _ref2[_i];
      if (e.bits < args.thresh) {
        j.removed_edges.push(e);
      } else {
        edges_kept.push(e);
      }
    }
    j.edges = edges_kept;
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  ## Output statistics about current graph
  */


  graph_stats = function(j, args, callback) {
    var c, cc, cl, cov, gc, i, ii, max_node, n50, n_ids, nid, o, p, s, scafnames, seq_tot, sn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Generate statistics about the assembly graph");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n\n        Example: " + args.help + " {\"file\":\"my_graph.txt\"} -- Write stats to the file\n        my_graph.txt\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n\nccdetail : true -- Write connected component details\n\n        Example: " + args.help + " {\"ccdetail\":true} -- Equivalent to GCC\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    o.write("Nodes: " + (Object.keys(j.nodes).length) + "\n");
    o.write("Edges: " + j.edges.length + "\n");
    o.write("Internal Edges: " + j.internal_edges.length + "\n");
    o.write("Shared Sequence Edges: " + j.shared_seq_edges.length + "\n");
    if (j.removed_nodes != null) {
      o.write("Removed Nodes: " + (Object.keys(j.removed_nodes).length) + "\n");
    }
    if (j.removed_edges != null) {
      o.write("Removed Edges: " + j.removed_edges.length + "\n");
    }
    _ref = calc_seq_stats(j.nodes), n50 = _ref[0], seq_tot = _ref[1], cov = _ref[2], gc = _ref[3];
    o.write("Total sequence length: " + seq_tot + "  N50: " + n50 + "\n");
    o.write("Mean coverage: " + (cov.toFixed(1)) + "  GC content: " + (gc.toFixed(1)) + "%\n");
    if ((j.clusters != null) && (j.scaffolds != null)) {
      o.write("\nScaffold Clusters: " + j.clusters.length + "\n");
      if (args.ccdetail != null) {
        o.write("\nScaffold Cluster details: \nclust\tscaffs\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig\n");
        _ref1 = j.clusters;
        for (ii = _i = 0, _len = _ref1.length; _i < _len; ii = ++_i) {
          cl = _ref1[ii];
          n_ids = [];
          for (_j = 0, _len1 = cl.length; _j < _len1; _j++) {
            cc = cl[_j];
            n_ids = n_ids.concat(j.scaffolds[cc].nodes);
          }
          _ref2 = calc_seq_stats((function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = n_ids.length; _k < _len2; _k++) {
              nid = n_ids[_k];
              _results.push(j.nodes[nid]);
            }
            return _results;
          })()), n50 = _ref2[0], seq_tot = _ref2[1], cov = _ref2[2], gc = _ref2[3], max_node = _ref2[4];
          o.write("" + ii + "\t" + cl.length + "\t" + n_ids.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node + "\n");
          o.write("\n\tScaffold details:\n\tccnum\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig\tname\n");
          for (_k = 0, _len2 = cl.length; _k < _len2; _k++) {
            cc = cl[_k];
            _ref3 = calc_seq_stats((function() {
              var _l, _len3, _ref3, _results;
              _ref3 = j.scaffolds[cc].nodes;
              _results = [];
              for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
                nid = _ref3[_l];
                _results.push(j.nodes[nid]);
              }
              return _results;
            })()), n50 = _ref3[0], seq_tot = _ref3[1], cov = _ref3[2], gc = _ref3[3], max_node = _ref3[4];
            o.write("\t" + j.scaffolds[cc].ccnum + "\t" + j.scaffolds[cc].nodes.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node + "\t" + cc + "\n");
          }
          o.write("\n");
        }
      }
    }
    if (j.connected_comps != null) {
      o.write("\nConnected components: " + j.connected_comps.length + "\n");
      if (args.ccdetail != null) {
        o.write("\nConnected component details:\nccnum\tnodes\tseqlen\tcov\t%GC\tn50\tlongest contig");
        if (j.scaffolds != null) {
          o.write("\tscaffold name\n");
          scafnames = [];
          _ref4 = j.scaffolds;
          for (sn in _ref4) {
            s = _ref4[sn];
            scafnames[s.ccnum] = sn;
          }
        } else {
          o.write("\n");
        }
        _ref5 = j.connected_comps;
        for (i = _l = 0, _len3 = _ref5.length; _l < _len3; i = ++_l) {
          c = _ref5[i];
          _ref6 = calc_seq_stats((function() {
            var _len4, _m, _results;
            _results = [];
            for (_m = 0, _len4 = c.length; _m < _len4; _m++) {
              nid = c[_m];
              _results.push(j.nodes[nid]);
            }
            return _results;
          })()), n50 = _ref6[0], seq_tot = _ref6[1], cov = _ref6[2], gc = _ref6[3], max_node = _ref6[4];
          o.write("" + i + "\t" + c.length + "\t" + seq_tot + "\t" + (cov.toFixed(1)) + "\t" + (gc.toFixed(1)) + "%\t" + n50 + "\t" + max_node);
          if ((scafnames != null ? scafnames[i] : void 0) != null) {
            o.write("\t" + scafnames[i] + "\n");
          } else {
            o.write("\n");
          }
        }
      }
    }
    o.write("\nProcessing steps completed (command history for this graph):\n");
    _ref8 = (_ref7 = j.processing) != null ? _ref7.slice(0, -1) : void 0;
    for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
      p = _ref8[_m];
      o.write("" + p[0] + "\t" + p[1] + "\t" + (p[2] ? JSON.stringify(p[2]) : void 0) + "\n");
    }
    o.write("\nStash contains " + stash_stack.length + " saved graph" + (stash_stack.length !== 1 ? 's' : void 0) + ".\n");
    if ((args.ccdetail != null) && stash_stack.length) {
      o.write("\nCommand histories for all stashed graphs (top to bottom of stack)\n");
      stash_stack.reverse();
      for (i = _n = 0, _len5 = stash_stack.length; _n < _len5; i = ++_n) {
        s = stash_stack[i];
        o.write("\nStack position " + (stash_stack.length - i) + " " + (i === 0 ? '[top]' : '') + (i === stash_stack.length - 1 ? '[bottom]' : '') + ":\n\n");
        _ref10 = (_ref9 = s.processing) != null ? _ref9.slice(0, -1) : void 0;
        for (_o = 0, _len6 = _ref10.length; _o < _len6; _o++) {
          p = _ref10[_o];
          o.write("" + p[0] + "\t" + p[1] + "\t" + p[2] + "\t" + (p[3] ? JSON.stringify(p[3]) : void 0) + "\n");
        }
      }
      stash_stack.reverse();
    }
    return close_output_stream(o, function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  ## Print graph statistics with CC detail and other details
  ## Shortcut equivalent to:  GC {"ccdetail":true}
  */


  graph_stats_cc = function(j, args, callback) {
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Generate statistics about the assembly graph, with details about\n       each connected component");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n\n        Example: " + args.help + " {\"file\":\"my_graph_ccs.txt\"} -- Write stats to the file\n        my_graph_ccs.txt\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    args.ccdetail = true;
    return graph_stats(j, args, callback);
  };

  /*
  # Write DOT output file from active nodes and edges.
  #
  # There is a fair amount of default "style" applied here with a few options.
  #  
  # To change styles (or provide alternatives), don't add a lot of code here,
  # rather you should look into the "gvpr" language that comes with the graphviz 
  # tools... It is purpose built for re-styling DOT files, etc before rendering.
  */


  export_dot = function(j, args, callback) {
    var doublecircle, edge, edge_type, h, name, node, o, _i, _len, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Write the current assembly graph to the graphviz DOT format");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.dot[.gz]\" -- name of dot format file to write graph to\n\n        Example: " + args.help + " {\"file\":\"my_graph.dot\"} -- Write stats to the file\n        my_graph.dot\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write graph to STDOUT\n\ndetail : true -- Draw labelled contig nodes\n\n        Example: " + args.help + " {\"detail\":true} -- Draw contigs as ovals containing\n        the node names of each contig. Note that this disables scaling the node size\n        by contig length.\n\narrowtype : \"arrowtype_string\" -- Control the type of arrowheads drawn.\n\n        Example: " + args.help + " {\"arrowtype\":\"normal\"} -- Default. Draw normal arrows\n        See graphviz documentation at:\n        http://www.graphviz.org/doc/info/attrs.html#k:arrowType\n\npen_scale : <float> -- Control the relative thickness of the arrow lines.\n\n        Example: " + args.help + " {\"pen_scale\":0.1} -- Default. Draw normal arrows\n        See graphviz documentation at:\n        http://www.graphviz.org/doc/info/attrs.html#d:penwidth\n\nconst_edge : true -- Draw connection arrow lines at constant width\n\n        Example: " + args.help + " {\"const_edge\":true} -- Draw edge arrows of constant width\n        regardless of bitscore.\n\ncolored_edges : true -- Draw edges colored by the GC% of the connected contigs\n\n        Example: " + args.help + " {\"colored_edges\":true} -- Draw colored arrows\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if ((_ref = args.arrowtype) == null) {
      args.arrowtype = "normal";
    }
    if ((_ref1 = args.pen_scale) == null) {
      args.pen_scale = 0.1;
    }
    doublecircle = "shape = \"doublecircle\" style=\"filled\" color = \"red\" penwidth = 3";
    if (j.SEASTAR_version != null) {
      if (j.digraph) {
        o.write("di");
      }
      o.write("graph \"" + ((_ref2 = args.file) != null ? _ref2 : 'Unnamed') + "\" {\n");
      o.write("graph [K = 0.5, repulsiveforce = 1.5, overlap = \"prism\", overlap_scaling = 10000.0];\n");
      if (!args.detail) {
        o.write("node [shape=\"point\"];\n");
      } else {
        o.write("node [style=\"filled\"];\n");
      }
      o.write("edge [arrowhead=\"" + args.arrowtype + "\"];\n");
      _ref3 = j.nodes;
      for (name in _ref3) {
        node = _ref3[name];
        h = (((_ref4 = node.pct_gc) != null ? _ref4 : 0) - 30.0) / 30.0;
        if (h < 0.0) {
          h = 0.0;
        }
        if (h > 1.0) {
          h = 1.0;
        }
        o.write("\"" + name + "\" [bits = " + (((_ref5 = node.bits) != null ? _ref5 : 0).toFixed(4)) + ", rel_ab = " + (((_ref6 = node.rel_ab) != null ? _ref6 : 0).toFixed(15)) + ", cov = " + (((_ref7 = node.cov) != null ? _ref7 : 0).toFixed(4)) + ", cov2 = " + (((_ref8 = node.adj_cov) != null ? _ref8 : 0).toFixed(4)) + ", uncov = " + ((((_ref9 = node.pct_uncov) != null ? _ref9 : 0) / 100.0).toFixed(4)) + ", seq_len = " + (((_ref10 = node.seq_len) != null ? _ref10 : 0).toFixed(0)) + ", rd_len = " + (((_ref11 = node.rd_len) != null ? _ref11 : 0).toFixed(1)) + ", gc = " + ((((_ref12 = node.pct_gc) != null ? _ref12 : 0) / 100.0).toFixed(4)) + ", n_shr = " + (((_ref13 = node.mp_sh) != null ? _ref13 : 0).toFixed(0)) + ", n_bwd = " + (((_ref14 = node.mp_bwd) != null ? _ref14 : 0).toFixed(0)) + ", n_fwd = " + (((_ref15 = node.mp_fwd) != null ? _ref15 : 0).toFixed(0)) + ", mp_mean = " + (((_ref16 = node.mp_ins_mean) != null ? _ref16 : 0).toFixed(4)) + ", mp_stdev = " + (((_ref17 = node.mp_ins_stdev) != null ? _ref17 : 0).toFixed(4)) + ", mp_sl_pairs = " + (((_ref18 = node.mp_pairs) != null ? _ref18 : 0).toFixed(0)) + ", name = \"" + name + "\", width = " + (0.01 * Math.sqrt(node.seq_len)) + " fillcolor = \"" + h + ",1.0,0.8\" color = \"" + h + ",1.0,0.5\" label = \"" + ((args.detail === 2) && (node.desc != null) ? node.desc : name) + "\" " + (node.contig_problems != null ? doublecircle : "") + "];\n");
      }
      _ref19 = j.edges;
      for (_i = 0, _len = _ref19.length; _i < _len; _i++) {
        edge = _ref19[_i];
        edge_type = edge.dir === "pos" || edge.dir === "forward" ? "->" : "--";
        if (edge.dir === "pos" || edge.interscaffold) {
          o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = DEP, dir = " + edge.dir + ", penwidth = " + (args.pen_scale * Math.sqrt(((!args.const_edge) && (edge.score > 0) ? edge.score : 5))) + ", color = red];\n");
        } else if (!args.colored_edges) {
          o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = MP, dir = " + edge.dir + ", bits = " + (edge.bits.toFixed(3)) + ", score = " + ((_ref20 = edge.score) != null ? _ref20.toFixed(3) : void 0) + ", pos1 = " + edge.p1 + ", pos2 = " + edge.p2 + ", penwidth = " + (args.pen_scale * Math.sqrt(((!args.const_edge) && (edge.score > 0) ? edge.score : 1))) + ", arrowsize = " + (0.1 * (Math.log(((!args.const_edge) && (edge.score > 0) ? edge.score : 1), 2))) + ", color = black];\n");
        } else {
          h = (((((_ref21 = edge.src.pct_gc) != null ? _ref21 : 0) + ((_ref22 = edge.tar.pct_gc) != null ? _ref22 : 0)) / 2) - 30.0) / 30.0;
          if (h < 0.0) {
            h = 0.0;
          }
          if (h > 1.0) {
            h = 1.0;
          }
          o.write("\"" + edge.n1 + "\" " + edge_type + " \"" + edge.n2 + "\" [type = MP, dir = " + edge.dir + ", bits = " + (edge.bits.toFixed(3)) + ", score = " + ((_ref23 = edge.score) != null ? _ref23.toFixed(3) : void 0) + ", pos1 = " + edge.p1 + ", pos2 = " + edge.p2 + ", penwidth = " + (args.pen_scale * Math.sqrt(((!args.const_edge) && (edge.score > 0) ? edge.score : 1))) + ", arrowsize = " + (0.1 * (Math.log(((!args.const_edge) && (edge.score > 0) ? edge.score : 1), 2))) + ", color = \"" + h + ",1.0,0.5\"];\n");
        }
      }
      o.write("}\n");
    }
    remove_graph_refs(j);
    return close_output_stream(o, function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  # FASTA file output
  */


  export_fasta = function(j, args, callback) {
    var name, node, o, options, scaf, write_scaffolds, _ref;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn("" + args.help + " --Write sequences contained in the current graph data to a FASTA format file.");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.fasta[.gz]\" -- name of FASTA format file to write sequence to\n\n        Example: " + args.help + " {\"file\":\"my_seq.fasta\"} -- Write stats to the file\n        my_seq.fasta\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write sequence to STDOUT\n\nscaff : true -- Output fully scaffolded sequences (using seq_scaffold tool)\n\n        Example: " + args.help + " {\"scaff\":true} -- Output scaffolded contig sequences\n\n                NOTE: Using this option as in the above example will run seq_scaffold with its\n        default settings.  As an advanced option, this parameter can also accept a string\n        argument, which will be passed along to the external seq_scaffold tool as its\n        [options] parameter string. Run with --help for help with the settings offered by\n        seq_scaffold and the default values.\n\n        Example: " + args.help + " {\"scaff\":\"--help\"}\n\n        Example: " + args.help + " {\"scaff\":\"--overlap=7 --heal=othercontigs.fna\"}\n\nno_merge_scaffs : true -- Write contig sequences in scaffold order with a scaffold ID in\n        each header, ready to be provided to the seq_scaffold tool\n\n        Example: " + args.help + " {\"no_merge_scafs\":true} -- Output ordered contig sequences\n\nabundance : true -- append relative abundance values to the FASTA sequence IDs\n\n        Example: " + args.help + " {\"abundance\":true} -- Attach abundances\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (args.no_merge_scaffs) {
      args.scaff = true;
    }
    if (args.scaff && (j.scaffolds == null)) {
      if (typeof callback === "function") {
        callback(new Error("Can't write scaffolded sequence before the SCAFF command has been run."), null);
      }
      return;
    }
    if (args.stream == null) {
      o = open_output_stream(args.file);
    } else {
      o = args.stream;
    }
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        console.error(err);
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (!args.scaff) {
      _ref = j.nodes;
      for (name in _ref) {
        node = _ref[name];
        if (node.recon_seq != null) {
          if (args.abundance != null) {
            o.write(">" + name + "_" + ((node.rel_ab * 100).toFixed(6)) + "\n");
          } else {
            o.write(">" + name + "\n");
          }
          o.write("" + node.recon_seq + "\n");
        }
      }
      return close_output_stream(o, function(error) {
        if (error) {
          return typeof callback === "function" ? callback(error, null) : void 0;
        } else {
          return typeof callback === "function" ? callback(null, j) : void 0;
        }
      });
    } else {
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      try {
        build_graph_refs(j);
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      write_scaffolds = function(out) {
        var nid, scaf, scaf_name, _ref1, _results;
        _ref1 = j.scaffolds;
        _results = [];
        for (scaf_name in _ref1) {
          scaf = _ref1[scaf_name];
          _results.push((function() {
            var _i, _len, _ref2, _results1;
            _ref2 = scaf.nodes;
            _results1 = [];
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              nid = _ref2[_i];
              node = j.nodes[nid];
              if (node.recon_seq != null) {
                out.write(">" + node.id + " " + scaf_name + "\n");
                _results1.push(out.write("" + node.recon_seq + "\n"));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      };
      if (args.no_merge_scaffs) {
        write_scaffolds(o);
        close_output_stream(o, function(error) {}, error ? typeof callback === "function" ? callback(error, null) : void 0 : typeof callback === "function" ? callback(null, j) : void 0);
      } else {
        if (typeof args.scaff === 'string') {
          options = args.scaff.split(/\s+/);
          options.push('-');
        } else {
          options = ['-'];
        }
        scaf = child_process.spawn('seq_scaffold', options, {});
        scaf.stdout.setEncoding('ascii');
        scaf.stderr.setEncoding('ascii');
        scaf.stdout.on('data', function(data) {
          return o.write(data);
        });
        scaf.stderr.on('data', function(data) {
          return process.stderr.write(data);
        });
        scaf.stdout.on('end', function() {
          return close_output_stream(o, function(error) {
            if (error) {
              return typeof callback === "function" ? callback(error, null) : void 0;
            } else {
              return typeof callback === "function" ? callback(null, j) : void 0;
            }
          });
        });
        scaf.on('exit', function(code) {
          if (code) {
            console.error('ERROR: ' + code);
            return typeof callback === "function" ? callback(new Error('SEAStAR script "seq_scaffold" could not be executed. Please check that this file is in your PATH.'), null) : void 0;
          }
        });
        write_scaffolds(scaf.stdin);
        scaf.stdin.end();
      }
      return remove_graph_refs(j);
    }
  };

  /*
  # old ref_select style table output
  #
  # This table is used by the 16S abundance pipeline and for doing transcriptomics analysis
  */


  export_table = function(j, args, callback) {
    var name, node, o, _ref, _ref1;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Write ref_select statistics for selected reference sequences to a TSV file");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.tsv[.gz]\" -- Specify a file name to write the TSV format stats table to.\n        If the filename contains one or more '#' characters in a row, these positions are\n        replaced with zero-padded digits that will increment each time a file is written to\n        this filename pattern. If no '#' characters are present, then this command overwrites\n        any existing file of the same name. (See DUMP command an example using this behavior)\n\n        Example: " + args.help + " {\"file\":\"my_seq.tsv\"} -- Write stats to the file\n        my_seq.tsv\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write stats to STDOUT\n\nheader : true -- write a header row with labels for each column\n\n        Example: " + args.help + " {\"header\":true} -- Write a header row. The fields are:\n\n        bitscore - Information content of reads aligning with the ref sequence\n        read_cnt - Number of (possibly fractional) reads aligning with the ref sequence\n        norm_cnt - Read_cnt normalized to ref sequence length\n        rel_abun - Relative fractional abundance of (copy number of) the ref sequence to\n                     all selected sequences (those with bitscores above some thresh)\n        mean_cov - Mean coverage of the reference sequence by (possibly fractional) reads\n        read_len - Mean length of reads aligning with this sequence\n        seq_len  - Length of the ref sequence\n        pct_gc   - Percent GC content of ref seqeunce (NA if not calculated)\n        name     - Catalog name of the ref sequence\n        desc     - Catalog description of the ref sequence\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.header) {
      o.write("id\tbitscore\tread_cnt\tnorm_cnt\trel_abun\tmean_cov\tread_len\tseq_len\tpct_gc\tname\tdesc\n");
    }
    _ref = j.nodes;
    for (name in _ref) {
      node = _ref[name];
      o.write("" + name + "\t" + node.bits + "\t" + node.rd_cnt + "\t" + node.int_cov + "\t" + node.rel_ab + "\t" + node.cov + "\t" + node.rd_len + "\t" + node.seq_len + "\t" + ((_ref1 = node.pct_gc) != null ? _ref1 : 'NA') + "\t" + node.name + "\t" + node.desc + "\n");
    }
    return close_output_stream(o, function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  # Reduces the graph to nodes in the object containing node_ids
  */


  execute_selection = function(j, nodes) {
    var e, edges_kept, id, internal_edges_kept, n, removed_edges_kept, removed_nodes_kept, shared_edges_kept, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    edges_kept = [];
    removed_edges_kept = [];
    removed_nodes_kept = {};
    internal_edges_kept = [];
    shared_edges_kept = [];
    try {
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    for (id in nodes) {
      n = nodes[id];
      _ref = n.inlinks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (nodes[e[1].id] != null) {
          edges_kept.push(e[0]);
        }
      }
      _ref1 = n.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        e = _ref1[_j];
        if (nodes[e[1].id] == null) {
          removed_edges_kept.push(e[0]);
          removed_nodes_kept[e[1].id] = e[1];
        }
      }
      _ref2 = n.rem_inlinks;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        e = _ref2[_k];
        if (nodes[e[1].id] != null) {
          removed_edges_kept.push(e[0]);
        }
      }
      _ref3 = n.rem_links;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        e = _ref3[_l];
        if (nodes[e[1].id] == null) {
          removed_edges_kept.push(e[0]);
          removed_nodes_kept[e[1].id] = e[1];
        }
      }
    }
    for (id in removed_nodes_kept) {
      n = removed_nodes_kept[id];
      _ref4 = n.rem_inlinks;
      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
        e = _ref4[_m];
        if (removed_nodes_kept[e[1].id] != null) {
          removed_edges_kept.push(e[0]);
        }
      }
    }
    j.nodes = nodes;
    j.edges = edges_kept;
    j.removed_edges = removed_edges_kept;
    j.removed_nodes = removed_nodes_kept;
    j.shared_seq_edges = (function() {
      var _len5, _n, _ref5, _results;
      _ref5 = j.shared_seq_edges;
      _results = [];
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        e = _ref5[_n];
        if ((nodes[e.n1] != null) || (nodes[e.n2] != null) || (removed_nodes_kept[e.n1] != null) || (removed_nodes_kept[e.n2] != null)) {
          _results.push(e);
        }
      }
      return _results;
    })();
    j.internal_edges = (function() {
      var _len5, _n, _ref5, _results;
      _ref5 = j.internal_edges;
      _results = [];
      for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
        e = _ref5[_n];
        if ((nodes[e.n1] != null) || (removed_nodes_kept[e.n1] != null)) {
          _results.push(e);
        }
      }
      return _results;
    })();
    return j;
  };

  /*
  # Select ccomps for output or further processing
  #
  # args (mutually exclusive):
  #     ccname = string id of a node to find in a cc
  #     ccnames = list of strings of names to find in multiple
  #     ccnum = number of a cc to select
  #     ccrange = start and end ccnums to select a range e.g. [0,10] or [1,-1]
  #     ccnums = list of numbers of ccs to select
  #     min_nodes = minimum number of nodes in cc
  #     min_seqlen = minimum amount of sequence in nodes in cc
  #
  */


  grab_ccomps = function(j, args, callback) {
    var c, cc, i, id, new_cclist, nid, nodes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Select specific connected components for further processing");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nccname : \"contig_name\" -- Select the connected component containing the named contig\n\n        Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Select the connected component\n        containing the contig named NODE_1234\nccnames : [\"contig_name1\",\"contig_name2\",...] -- Select the connected component(s)\n        containing the named contigs\n\n        Example: " + args.help + " {\"ccnames\":[\"NODE_1234\",\"NODE_5678\"]} -- Select the\n        connected components containing the contigs named NODE_1234 and NODE_5678\n\nccnum : <int> -- Select connected component number <int>\n\n        Example: " + args.help + " {\"ccnum\":0} -- Default. Select connected component 0.\n\nccnums : [<int>,<int>,...] -- Select the connected components from the list of numbers\n\n        Example: " + args.help + " {\"ccnums\":[1,2]} -- Select the second and third\n        connected components (numbering is zero based)\n\nccrange : [<int1>,<int2>] -- Select the connected components numbered in the range\n        <int1>..<int2> (inclusive).\n\n        NOTE: <int> may be negative, indicating positions at the end of the list of\n        connected components.\n\n        Example: " + args.help + " {\"ccrange\":[0,5]} -- Select the first 6 connected\n        components\n\n        Example: " + args.help + " {\"ccrange\":[-5,-1]} -- Select the last 5 connected\n        components\n\nmin_nodes : <int> -- Select connected components with <int> or more nodes.\n\n        Example: " + args.help + " {\"min_nodes\":2} -- Select connected components\n        with 2 or more nodes.\n\nmin_seqlen : <int> -- Select connected components with <int> or more sequence within nodes.\n\n        Example: " + args.help + " {\"min_seqlen\":1000} -- Select connected components containing\n        at least 1000 bases of sequence.\n        ");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.ccname != null) {
      _ref = j.connected_comps;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        c = _ref[i];
        if (!(c.indexOf(args.ccname) !== -1)) {
          continue;
        }
        args.ccnums = [i];
        break;
      }
    } else if (args.ccnames != null) {
      args.ccnums = [];
      _ref1 = args.ccnames;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        _ref2 = j.connected_comps;
        for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
          c = _ref2[i];
          if (!(c.indexOf(id) !== -1 && args.ccnums.indexOf(i) === -1)) {
            continue;
          }
          args.ccnums.push(i);
          break;
        }
      }
    } else if (args.ccnum != null) {
      args.ccnums = [args.ccnum];
    } else if (args.ccrange != null) {
      if (args.ccrange[0] < 0) {
        args.ccrange[0] = j.connected_comps.length + args.ccrange[0];
      }
      if (args.ccrange[1] < 0) {
        args.ccrange[1] = j.connected_comps.length + args.ccrange[1];
      }
      args.ccnums = (function() {
        _results = [];
        for (var _l = _ref3 = args.ccrange[0], _ref4 = args.ccrange[1]; _ref3 <= _ref4 ? _l <= _ref4 : _l >= _ref4; _ref3 <= _ref4 ? _l++ : _l--){ _results.push(_l); }
        return _results;
      }).apply(this);
    } else if (args.min_nodes != null) {
      args.ccnums = [];
      _ref5 = j.connected_comps;
      for (i = _m = 0, _len3 = _ref5.length; _m < _len3; i = ++_m) {
        c = _ref5[i];
        if (c.length >= args.min_nodes) {
          args.ccnums.push(i);
        }
      }
    } else if (args.min_seqlen != null) {
      args.ccnums = [];
      _ref6 = j.connected_comps;
      for (i = _n = 0, _len4 = _ref6.length; _n < _len4; i = ++_n) {
        c = _ref6[i];
        if (cc_seq_len(j, c) >= args.min_seqlen) {
          args.ccnums.push(i);
        }
      }
    } else {
      if ((_ref7 = args.ccnums) == null) {
        args.ccnums = [0];
      }
    }
    if (args.ccnums == null) {
      if (typeof callback === "function") {
        callback(new Error("No connected components found matching selection criteria"), null);
      }
      return;
    }
    nodes = {};
    new_cclist = [];
    _ref8 = args.ccnums;
    for (_o = 0, _len5 = _ref8.length; _o < _len5; _o++) {
      cc = _ref8[_o];
      if (j.connected_comps[cc] == null) {
        if (typeof callback === "function") {
          callback(new Error("Invalid selected ccnum: " + cc + ".  ccnums are zero-based and there are only " + j.connected_comps.length + " ccomps in this graph."), null);
        }
        return;
      }
      new_cclist.push(j.connected_comps[cc]);
      _ref9 = j.connected_comps[cc];
      for (_p = 0, _len6 = _ref9.length; _p < _len6; _p++) {
        nid = _ref9[_p];
        nodes[nid] = j.nodes[nid];
      }
    }
    execute_selection(j, nodes);
    delete j.connected_comps;
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Select nodes and neighbors for output or further processing
  */


  find_neighbors = function(nd, r) {
    var l, n, nodeid_list, _i, _len, _ref, _ref1;
    nodeid_list = [nd.id];
    nd.seen = true;
    if (r > 0) {
      _ref = nd.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], l = _ref1[0], n = _ref1[1];
        if (!n.seen) {
          nodeid_list = nodeid_list.concat(find_neighbors(n, r - 1));
        }
      }
    }
    return nodeid_list;
  };

  /*
  #   Adds neighboring nodes to the selected list
  #
  # args:
  #     name = string id of a node to find in a cc
  #     names = list of strings of names to find in multiple
  #     radius = number of hops to take searching for neighoring nodes
  */


  grab_neighbors = function(j, args, callback) {
    var name, nid, nodes, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Select contigs from the connected neighborhood(s) of the given contig(s)");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nname : \"contig_name\" -- Use a single contig by name\n\n        Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Select NODE_1234 (and its\n        neighbors)\n\nnames : [\"contig_name1\",\"contig_name2\",...] -- Use multiple contigs by name\n\n        Example: " + args.help + " {\"names\":[\"NODE_1234\",\"NODE_5678\"]} -- Select these\n        two contigs (and their neighbors...)\n\nradius : <int> -- Size of the neighborhood of contigs to select\n\n        Example: " + args.help + " {\"radius\":2} -- Select all neighbors and neighbors of\n                neighbors\n\n        Example: " + args.help + " {\"radius\":0} -- Default. Select only the named contig(s)\n        ");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.name != null) {
      args.names = [args.name];
    }
    if ((_ref = args.radius) == null) {
      args.radius = 0;
    }
    nodes = {};
    _ref1 = args.names;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      _ref2 = find_neighbors(j.nodes[name], args.radius);
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        nid = _ref2[_j];
        nodes[nid] = j.nodes[nid];
      }
    }
    execute_selection(j, nodes);
    remove_graph_refs(j, function(n) {
      return delete n.seen;
    });
    delete j.connected_comps;
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Add ends
  */


  add_ends = function(j, args, callback) {
    var c, e, head_node, i, tail_node, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Extends scaffold ends (reversing the action of PLUCK at scaffold ends)");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\niterate : <int> -- number of iterations of " + args.help + " to run. Each is equivalent to\n       running " + args.help + " again as a separate command.  By Default <int> = 3\n\n        Example: " + args.help + " {\"iterate\":2} -- Equivalent of " + args.help + " " + args.help + "\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.iterate) == null) {
      args.iterate = 3;
    }
    for (i = _i = _ref1 = args.iterate; _ref1 <= 1 ? _i <= 1 : _i >= 1; i = _ref1 <= 1 ? ++_i : --_i) {
      if (j.connected_comps == null) {
        calc_ccomps(j);
      }
      try {
        build_graph_refs(j);
        build_removed_graph_refs(j);
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      _ref2 = j.connected_comps;
      for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
        c = _ref2[_j];
        try {
          _ref3 = find_ends(j, c, true), (_ref4 = _ref3[0], head_node = _ref4[0]), (_ref5 = _ref3[1], tail_node = _ref5[0]);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        if (!head_node.no_push) {
          _ref6 = head_node.rem_inlinks;
          for (_k = 0, _len1 = _ref6.length; _k < _len1; _k++) {
            e = _ref6[_k];
            if (!(e[0].dir === "forward" && e[0].pluck_iteration === i && (j.nodes[e[0].n1] == null))) {
              continue;
            }
            j.edges.push(e[0]);
            j.nodes[e[1].id] = e[1];
            delete j.removed_nodes[e[1].id];
            delete j.removed_edges[e[0].index];
            break;
          }
        }
        if (!tail_node.no_push) {
          _ref7 = tail_node.rem_outlinks;
          for (_l = 0, _len2 = _ref7.length; _l < _len2; _l++) {
            e = _ref7[_l];
            if (!(e[0].dir === "forward" && e[0].pluck_iteration === i && (j.nodes[e[0].n2] == null))) {
              continue;
            }
            j.edges.push(e[0]);
            j.nodes[e[1].id] = e[1];
            delete j.removed_nodes[e[1].id];
            delete j.removed_edges[e[0].index];
            break;
          }
        }
      }
      if (i !== 1) {
        remove_graph_refs(j);
      }
      delete j.connected_comps;
    }
    remove_graph_refs(j, null, (function(e) {
      return delete e.pluck_iteration;
    }));
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Functions for finding connections between scaffold ends
  */


  find_direct_connection = function(head, tail, thresh) {
    var edge, select_edge, try_dir_links, _ref, _ref1, _ref2, _ref3;
    if (thresh == null) {
      thresh = 0;
    }
    try_dir_links = function(h, t) {
      var e, l, _i, _len, _ref;
      _ref = h.rem_links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l[1].id === t.id && (e = edge_director(t, h, l[0])) && t.id === e.n1) {
          break;
        } else {
          e = null;
        }
      }
      if (e) {
        return [e];
      } else {
        return null;
      }
    };
    select_edge = null;
    if ((edge = try_dir_links(head, tail)) && ((_ref = edge[0]) != null ? _ref.bits : void 0) > thresh) {
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links(head.outlinks[0][1], tail)) && ((_ref1 = edge[0]) != null ? _ref1.bits : void 0) > thresh) {
      head = head.outlinks[0][1];
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links(head, tail.inlinks[0][1])) && ((_ref2 = edge[0]) != null ? _ref2.bits : void 0) > thresh) {
      tail = tail.inlinks[0][1];
      select_edge = edge;
      thresh = edge[0].bits;
    }
    if ((edge = try_dir_links(head.outlinks[0][1], tail.inlinks[0][1])) && ((_ref3 = edge[0]) != null ? _ref3.bits : void 0) > thresh) {
      head = head.outlinks[0][1];
      tail = tail.inlinks[0][1];
      select_edge = edge;
      thresh = edge[0].bits;
    }
    return [select_edge, head, tail, thresh];
  };

  /*
  # Look for indirect connections (via another node not part of either scaffold)
  */


  find_indirect_connection = function(head, tail, thresh) {
    var result, select_result, try_indir_links, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (thresh == null) {
      thresh = 0;
    }
    try_indir_links = function(h, t) {
      var eh, et, hnodes, l, _i, _j, _len, _len1, _ref, _ref1;
      hnodes = {};
      _ref = h.rem_links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        hnodes[l[1].id] = l;
      }
      _ref1 = t.rem_links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        l = _ref1[_j];
        if (hnodes[l[1].id] != null) {
          if ((et = edge_director(t, l[1], l[0])) && (t.id === et.n1) && (eh = edge_director(hnodes[l[1].id][1], h, hnodes[l[1].id][0])) && (h.id === eh.n2)) {
            break;
          } else {
            et = null;
            eh = null;
          }
        }
      }
      if (et && eh) {
        return [et, eh];
      } else {
        return null;
      }
    };
    select_result = null;
    if ((result = try_indir_links(head.outlinks[0][1], tail.inlinks[0][1])) && (result != null ? (_ref = result[0]) != null ? _ref.bits : void 0 : void 0) > thresh && (result != null ? (_ref1 = result[1]) != null ? _ref1.bits : void 0 : void 0) > thresh) {
      head = head.outlinks[0][1];
      tail = tail.inlinks[0][1];
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links(head, tail.inlinks[0][1])) && (result != null ? (_ref2 = result[0]) != null ? _ref2.bits : void 0 : void 0) > thresh && (result != null ? (_ref3 = result[1]) != null ? _ref3.bits : void 0 : void 0) > thresh) {
      tail = tail.inlinks[0][1];
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links(head.outlinks[0][1], tail)) && (result != null ? (_ref4 = result[0]) != null ? _ref4.bits : void 0 : void 0) > thresh && (result != null ? (_ref5 = result[1]) != null ? _ref5.bits : void 0 : void 0) > thresh) {
      head = head.outlinks[0][1];
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    if ((result = try_indir_links(head, tail)) && (result != null ? (_ref6 = result[0]) != null ? _ref6.score : void 0 : void 0) > thresh && (result != null ? (_ref7 = result[1]) != null ? _ref7.score : void 0 : void 0) > thresh) {
      select_result = result;
      thresh = Math.min(result[0].bits, result[1].bits);
    }
    return [select_result, head, tail, thresh];
  };

  /*
  # Look for both direct and indirect connections
  */


  find_connection = function(head, tail, thresh) {
    var direct, indirect;
    if (thresh == null) {
      thresh = 0;
    }
    direct = find_direct_connection(head, tail, thresh);
    if (direct[0]) {
      thresh = direct[3];
    }
    indirect = find_indirect_connection(head, tail, thresh);
    if (indirect[0]) {
      return indirect;
    } else {
      return direct;
    }
  };

  /*
  # Scaffold end-link
  */


  scaff_link = function(j, args, callback) {
    var c, cc, e1, e2, h1, h2, i, ii, n, t1, t2, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Find connections linking scaffold ends");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nthresh : <float> -- Bitscore threshold\n\n        Example: " + args.help + " {\"thresh\":1000.0}' -- Default. Only reconnect scaffold\n        ends with connections scoring at least 1000.0 bits\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.thresh) == null) {
      args.thresh = 1000.0;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    _ref1 = j.connected_comps;
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      c = _ref1[i];
      for (_j = 0, _len1 = c.length; _j < _len1; _j++) {
        n = c[_j];
        j.nodes[n].ccnum = i;
      }
    }
    _ref2 = j.connected_comps;
    for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
      c = _ref2[i];
      _ref3 = j.connected_comps;
      for (ii = _l = 0, _len3 = _ref3.length; _l < _len3; ii = ++_l) {
        cc = _ref3[ii];
        if (!(ii >= i)) {
          continue;
        }
        try {
          _ref4 = find_ends(j, c, true), (_ref5 = _ref4[0], h1 = _ref5[0]), (_ref6 = _ref4[1], t1 = _ref6[0]);
          _ref7 = find_ends(j, cc, true), (_ref8 = _ref7[0], h2 = _ref8[0]), (_ref9 = _ref7[1], t2 = _ref9[0]);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        e1 = find_connection(h1, t2, args.thresh)[0];
        if (e1) {
          if (e1.length === 1) {
            if (!e1[0].interscaffold) {
              e1[0].interscaffold = true;
              j.edges.push(e1[0]);
              delete j.removed_edges[e1[0].index];
            }
            console.warn("Scaffold " + ii + " " + e1[0].n1 + " --> Scaffold " + i + " " + e1[0].n2 + " -- " + e1[0].bits + " bits");
          } else {
            if (!e1[0].interscaffold) {
              e1[0].interscaffold = true;
              j.edges.push(e1[0]);
              delete j.removed_edges[e1[0].index];
            }
            if (!e1[1].interscaffold) {
              e1[1].interscaffold = true;
              j.edges.push(e1[1]);
              delete j.removed_edges[e1[1].index];
            }
            if (j.nodes[e1[1].n1] == null) {
              j.nodes[e1[1].n1] = e1[1].src;
              delete j.removed_nodes[e1[1].n1];
            }
            console.warn("Scaffold " + ii + " " + e1[0].n1 + " --> Scaffold " + e1[1].src.ccnum + " " + e1[1].n1 + " --> Scaffold " + i + " " + e1[1].n2 + " -- " + e1[0].bits + " + " + e1[1].bits + " bits");
          }
        }
        if (i !== ii) {
          e2 = find_connection(h2, t1, args.thresh)[0];
          if (e2) {
            if (e2.length === 1) {
              if (!e2[0].interscaffold) {
                e2[0].interscaffold = true;
                j.edges.push(e2[0]);
                delete j.removed_edges[e2[0].index];
              }
              console.warn("Scaffold " + i + " " + e2[0].n1 + " --> Scaffold " + ii + " " + e2[0].n2 + " -- " + e2[0].bits + " bits");
            } else {
              if (!e2[0].interscaffold) {
                e2[0].interscaffold = true;
                j.edges.push(e2[0]);
                delete j.removed_edges[e2[0].index];
              }
              if (!e2[1].interscaffold) {
                e2[1].interscaffold = true;
                j.edges.push(e2[1]);
                delete j.removed_edges[e2[1].index];
              }
              if (j.nodes[e2[1].n1] == null) {
                j.nodes[e2[1].n1] = e2[1].src;
                delete j.removed_nodes[e2[1].n1];
              }
              console.warn("Scaffold " + i + " " + e2[0].n1 + " --> Scaffold " + e2[1].src.ccnum + " " + e2[1].n1 + " --> Scaffold " + ii + " " + e2[1].n2 + " -- " + e2[0].bits + " + " + e2[1].bits + " bits");
            }
          }
        }
      }
    }
    remove_graph_refs(j, (function(n) {
      return delete n.ccnum;
    }));
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Relink
  */


  relink = function(j, args, callback) {
    var c, e, edge, edge_list, edges_added, id, in_nodes_added, n, name, nid, node_list, nodes_added, out_nodes_added, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _name, _name1, _o, _p, _q, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Reconnect previously removed connections between contigs");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nname : \"contig_name\" -- Use a single contig by name\n\n        Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Restore edges to this contig\n\nnames : [\"contig_name1\",\"contig_name2\",...] -- Use multiple contigs by name\n\n        Example: " + args.help + " {\"names\":[\"NODE_1234\",\"NODE_5678\"]} -- Restore edges\n        to these two contigs (though not necessarily between them...)\n\nccname : \"contig_name\" -- Use all contigs in the connected component containing the\n        named contig\n\n        Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Restore edges to all contigs\n        in the connected component containing this contig\n\nccnames : [\"contig_name1\",\"contig_name2\",...] -- Restore edges to all contigs\n        in the connected components containing these contigs\n\n        Example: " + args.help + " {\"names\":[\"NODE_1234\",\"NODE_5678\"]} -- Restore edges\n        to all contigs within the connected compontent(s) containing these two contigs\n\nradius : <int> -- Expand the sphere of restored connections to neighbors\n\n        Example: " + args.help + " {\"radius\":2} -- Restore edges to all contigs within two\n        hops of the selected contigs (including along newly restored paths)\n\ncomplete : true -- Restore connections among all types of contigs\n\n        Example: " + args.help + " {\"complete\":true} -- Restore connections among contigs\n        which are both removed from and part of currently selected connected components\n\nexisting : true -- Only restore connections between nodes currently part of selected\n        connected components\n\n        Example: " + args.help + " {\"existing\":true} -- Only add among to non-removed contigs\n\n        Note: If complete:false and existing:false (the Default case) then only\n        connections between contigs in currently selected connected components and those\n        removed from such components are restored.  That is, no new connections within\n        connected components are added.\n \nproblems : true -- Restore all connections to contigs that are marked with potential\n        assembly problems\n\n        Example: " + args.help + " {\"problems\":true} -- Reconnect all problem contigs to\n        all of their potential neighbors.  Uses radius:1 and existing:true\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if ((_ref = args.problems) == null) {
      args.problems = false;
    }
    if (args.problems) {
      args.radius = 1;
      args.existing = true;
      args.names = (function() {
        var _ref1, _results;
        _ref1 = j.nodes;
        _results = [];
        for (nid in _ref1) {
          n = _ref1[nid];
          if (n.contig_problems != null) {
            _results.push(nid);
          }
        }
        return _results;
      })();
    }
    if ((_ref1 = args.complete) == null) {
      args.complete = false;
    }
    if ((_ref2 = args.thresh) == null) {
      args.thresh = 0.0;
    }
    if ((_ref3 = args.radius) == null) {
      args.radius = 0;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    node_list = {};
    if (args.ccname != null) {
      args.ccnames = [args.ccname];
    }
    if (args.ccnames != null) {
      if ((_ref4 = args.names) == null) {
        args.names = [];
      }
      _ref5 = args.ccnames;
      for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
        id = _ref5[_i];
        _ref6 = j.connected_comps;
        for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
          c = _ref6[_j];
          if (c.indexOf(id) !== -1) {
            args.names = args.names.concat(c);
          }
        }
      }
    }
    if (args.name != null) {
      args.names = [args.name];
    }
    if (args.radius && (args.names != null)) {
      _ref7 = args.names;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        name = _ref7[_k];
        _ref8 = find_neighbors(j.nodes[name], args.radius);
        for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
          nid = _ref8[_l];
          node_list[nid] = j.nodes[nid];
        }
      }
    }
    if (args.names != null) {
      _ref9 = args.names;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        id = _ref9[_m];
        node_list[id] = j.nodes[id];
      }
    } else {
      node_list = j.nodes;
    }
    in_nodes_added = {};
    out_nodes_added = {};
    nodes_added = {};
    edges_added = [];
    if (!args.existing) {
      for (id in node_list) {
        n = node_list[id];
        _ref10 = n.rem_links;
        for (_n = 0, _len5 = _ref10.length; _n < _len5; _n++) {
          e = _ref10[_n];
          if ((j.removed_nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0]) && e[0].score >= args.thresh)) {
            if (id === edge.n1) {
              if ((_ref11 = out_nodes_added[_name = e[1].id]) == null) {
                out_nodes_added[_name] = [];
              }
              out_nodes_added[e[1].id].push(e[0]);
            } else {
              if ((_ref12 = in_nodes_added[_name1 = e[1].id]) == null) {
                in_nodes_added[_name1] = [];
              }
              in_nodes_added[e[1].id].push(e[0]);
            }
          }
        }
      }
      for (id in in_nodes_added) {
        edge_list = in_nodes_added[id];
        edges_added = edges_added.concat(edge_list);
        nodes_added[id] = j.removed_nodes[id];
      }
      for (id in out_nodes_added) {
        edge_list = out_nodes_added[id];
        edges_added = edges_added.concat(edge_list);
        nodes_added[id] = j.removed_nodes[id];
      }
      _ref13 = j.removed_edges;
      for (_o = 0, _len6 = _ref13.length; _o < _len6; _o++) {
        e = _ref13[_o];
        if (((e != null) && ((nodes_added[e.n1] != null) && (nodes_added[e.n2] != null))) && e[0].score >= args.thresh) {
          if ((edge = edge_director(e.src, e.tar, e))) {
            edges_added.push(edge);
          }
        }
      }
    }
    if (args.complete || args.existing) {
      for (id in node_list) {
        n = node_list[id];
        if ((!args.ends) || (n.links.length === 1)) {
          _ref14 = n.rem_inlinks;
          for (_p = 0, _len7 = _ref14.length; _p < _len7; _p++) {
            e = _ref14[_p];
            if (e[0].score >= args.thresh) {
              if ((j.nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0]))) {
                edges_added.push(edge);
                delete j.removed_edges[edge.index];
              }
            }
          }
        }
      }
    }
    for (id in nodes_added) {
      n = nodes_added[id];
      j.nodes[id] = n;
      delete j.removed_nodes[id];
    }
    for (_q = 0, _len8 = edges_added.length; _q < _len8; _q++) {
      e = edges_added[_q];
      j.edges.push(e);
      delete j.removed_edges[e.index];
    }
    delete j.connected_comps;
    remove_graph_refs(j, function(n) {
      return delete n.seen;
    });
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Full Ordering -- This is like Relink above, but it inserts extra dependency edges 
  # between added nodes based on mate-pair mapping positions in scaffold nodes
  */


  full_order = function(j, args, callback) {
    var add_dep_edges, base_n, base_p, c, cc_chain_levels, cc_list, chain_levels, chain_minmax, check_list, cnt, cur_lev, dep_edges_added, die, dup, e, e_n, e_p, edge, edge_list, edge_obj, edges_added, good, head, i, id, idx, in_idx, in_nodes_added, l, n, new_in_edges, new_in_idx, new_out_edges, new_out_idx, next, nid, node, node_id, nodes_added, out_idx, out_nodes_added, p, pos, pos_rank, prev, tail, _base, _i, _j, _k, _l, _len, _len1, _len10, _len11, _len12, _len13, _len14, _len15, _len16, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _name, _name1, _name2, _name3, _name4, _name5, _name6, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref23, _ref24, _ref25, _ref26, _ref27, _ref28, _ref29, _ref3, _ref30, _ref31, _ref32, _ref33, _ref34, _ref35, _ref36, _ref37, _ref38, _ref39, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _s, _t, _u, _v, _w, _x, _y, _z;
    if (args == null) {
      args = {
        "verbose": false
      };
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Reconnect contigs with ambiguous placement within a scaffold using mapped\n          pair position information to resolve ambiguities");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nccname : \"contig_name\" -- Use the connected component containing the named contig\n\n        Example: " + args.help + " {\"ccname\":\"NODE_1234\"} -- Insert removed contigs\n        within the connected component containing this contig\n\nccnames : [\"contig_name1\",\"contig_name2\",...] -- Insert removed contigs within the\n        connected components containing these contigs\n\nthresh : <float> -- Minimum contig connection bitscore to consider\n\n        Example: " + args.help + " {\"thresh\":250.0} -- Default. Only connections scoring\n        at least 250.0 bits will count in the calculations\n\nmin_pos_diff : <int> -- Minimum mapping position difference (within a neighboring contig)\n        considered reliable enough to use for resolving positional ambiguities.\n\n        Example: " + args.help + " {\"min_pos_diff\":75} -- Default. Only pairing information\n        yielding a relative position difference of 75 nucleotides (between candidate\n        contigs and a neighboring existing contig) will be considered significant enough\n        to use in determining the relative ordering of the candidate contigs\n\nverbose : true -- output diagnostics on STDERR\n\n        Example: " + args.help + " {\"verbose\":true} -- Generate extra output information\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    cc_list = [];
    if ((_ref = args.thresh) == null) {
      args.thresh = 250.0;
    }
    if ((_ref1 = args.min_pos_diff) == null) {
      args.min_pos_diff = 75;
    }
    if (args.ccname != null) {
      args.ccnames = [args.ccname];
    }
    if (args.ccnames != null) {
      _ref2 = args.ccnames;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        id = _ref2[_i];
        _ref3 = j.connected_comps;
        for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
          c = _ref3[i];
          if (c.indexOf(id) !== -1) {
            cc_list.push(i);
          }
        }
      }
    } else {
      cc_list = (function() {
        _results = [];
        for (var _k = 0, _ref4 = j.connected_comps.length; 0 <= _ref4 ? _k < _ref4 : _k > _ref4; 0 <= _ref4 ? _k++ : _k--){ _results.push(_k); }
        return _results;
      }).apply(this);
    }
    nodes_added = {};
    edges_added = [];
    cc_chain_levels = [];
    for (_l = 0, _len2 = cc_list.length; _l < _len2; _l++) {
      idx = cc_list[_l];
      in_nodes_added = {};
      out_nodes_added = {};
      in_idx = {};
      out_idx = {};
      c = j.connected_comps[idx];
      try {
        _ref5 = find_ends(j, c, true), (_ref6 = _ref5[0], head = _ref6[0]), (_ref7 = _ref5[1], tail = _ref7[0]);
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      chain_levels = [];
      n = head;
      i = 1;
      while (n) {
        chain_levels[i - 1] = n;
        n.chain_idx = i;
        n.ccnum = idx;
        n.cclen = c.length;
        i++;
        n = (_ref8 = n.outlinks[0]) != null ? _ref8[1] : void 0;
      }
      cc_chain_levels.push(chain_levels);
      for (l = _m = 0, _len3 = chain_levels.length; _m < _len3; l = ++_m) {
        n = chain_levels[l];
        _ref9 = n.rem_links;
        for (_n = 0, _len4 = _ref9.length; _n < _len4; _n++) {
          e = _ref9[_n];
          if ((j.removed_nodes[e[1].id] != null) && (edge = edge_director(n, e[1], e[0]))) {
            if (n.id === edge.n1) {
              if ((_ref10 = out_nodes_added[_name = e[1].id]) == null) {
                out_nodes_added[_name] = [];
              }
              out_nodes_added[e[1].id].push(e[0]);
              if ((_ref11 = out_idx[_name1 = e[1].id]) == null) {
                out_idx[_name1] = [];
              }
              out_idx[e[1].id].push(n.chain_idx);
            } else {
              if ((_ref12 = in_nodes_added[_name2 = e[1].id]) == null) {
                in_nodes_added[_name2] = [];
              }
              in_nodes_added[e[1].id].push(e[0]);
              if ((_ref13 = in_idx[_name3 = e[1].id]) == null) {
                in_idx[_name3] = [];
              }
              in_idx[e[1].id].push(n.chain_idx);
            }
          }
        }
      }
      for (id in in_nodes_added) {
        edge_list = in_nodes_added[id];
        if (!(out_nodes_added[id] == null)) {
          continue;
        }
        delete in_nodes_added[id];
        delete in_idx[id];
      }
      for (id in out_nodes_added) {
        edge_list = out_nodes_added[id];
        if (!(in_nodes_added[id] == null)) {
          continue;
        }
        delete out_nodes_added[id];
        delete out_idx[id];
      }
      chain_minmax = {};
      for (id in in_idx) {
        check_list = {};
        _ref14 = j.removed_nodes[id].rem_links;
        for (_o = 0, _len5 = _ref14.length; _o < _len5; _o++) {
          _ref15 = _ref14[_o], e = _ref15[0], n = _ref15[1];
          if (!(in_idx[n.id] != null)) {
            continue;
          }
          if ((_ref16 = check_list[_name4 = n.id]) == null) {
            check_list[_name4] = 0;
          }
          check_list[n.id]++;
        }
        die = false;
        for (nid in check_list) {
          cnt = check_list[nid];
          if (!(cnt > 1 && j.removed_nodes[id].seq_len < j.removed_nodes[nid].seq_len)) {
            continue;
          }
          die = true;
          if (args.verbose) {
            console.warn("Circular variant node " + id + " rejected");
          }
          break;
        }
        if (die) {
          break;
        }
        dup = false;
        if (nodes_added[id] != null) {
          if ((_ref17 = (_base = j.removed_nodes[id]).dup) == null) {
            _base.dup = 0;
          }
          j.removed_nodes[id].dup++;
          node_id = id + ("_Dup_" + j.removed_nodes[id].dup);
          node = {};
          for (p in j.removed_nodes[id]) {
            node[p] = j.removed_nodes[id][p];
          }
          node.name = node_id;
          node.id = node_id;
          dup = true;
        } else {
          node_id = id;
          node = j.removed_nodes[id];
        }
        chain_minmax = {
          ins: {
            min: Math.min.apply(null, out_idx[id]),
            max: Math.max.apply(null, out_idx[id])
          },
          outs: {
            min: Math.min.apply(null, in_idx[id]),
            max: Math.max.apply(null, in_idx[id])
          }
        };
        if ((chain_minmax.ins.max < chain_minmax.outs.min) && (chain_minmax.outs.max - chain_minmax.ins.min < 7)) {
          edges_added = edges_added.concat(out_nodes_added[id]).concat(in_nodes_added[id]);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, chain_minmax.outs.max];
          node.ccnum = idx;
        } else if ((chain_minmax.ins.min > chain_minmax.outs.max) && (chain_minmax.outs.max - chain_minmax.outs.min < 4) && (chain_minmax.ins.max - chain_minmax.ins.min < 4) && (chain_minmax.ins.min - chain_minmax.outs.max > j.connected_comps[idx].length - 7)) {
          edges_added = edges_added.concat(out_nodes_added[id]);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, Number.MAX_VALUE];
          node.ccnum = idx;
        } else if ((((chain_minmax.outs.min < (_ref19 = chain_minmax.ins.min) && _ref19 <= (_ref18 = chain_minmax.ins.max)) && _ref18 < chain_minmax.outs.max)) && (chain_minmax.ins.max - chain_minmax.ins.min < 4) && (chain_minmax.outs.max - chain_minmax.outs.min > j.connected_comps[idx].length - 7)) {
          new_out_edges = (function() {
            var _len6, _p, _ref20, _results1;
            _ref20 = in_nodes_added[id];
            _results1 = [];
            for (_p = 0, _len6 = _ref20.length; _p < _len6; _p++) {
              e = _ref20[_p];
              if (e.tar.chain_idx > chain_minmax.ins.max) {
                _results1.push(e);
              }
            }
            return _results1;
          })();
          new_out_idx = (function() {
            var _len6, _p, _results1;
            _results1 = [];
            for (_p = 0, _len6 = new_out_edges.length; _p < _len6; _p++) {
              e = new_out_edges[_p];
              _results1.push(e.tar.chain_idx);
            }
            return _results1;
          })();
          edges_added = edges_added.concat(out_nodes_added[id]).concat(new_out_edges);
          nodes_added[node_id] = node;
          node.slot = [chain_minmax.ins.min, Math.max.apply(null, new_out_idx)];
          node.ccnum = idx;
        } else if ((((chain_minmax.ins.min < (_ref21 = chain_minmax.outs.min) && _ref21 <= (_ref20 = chain_minmax.outs.max)) && _ref20 < chain_minmax.ins.max)) && (chain_minmax.outs.max - chain_minmax.outs.min < 4) && (chain_minmax.ins.max - chain_minmax.ins.min > j.connected_comps[idx].length - 7)) {
          new_in_edges = (function() {
            var _len6, _p, _ref22, _results1;
            _ref22 = out_nodes_added[id];
            _results1 = [];
            for (_p = 0, _len6 = _ref22.length; _p < _len6; _p++) {
              e = _ref22[_p];
              if (e.src.chain_idx < chain_minmax.outs.min) {
                _results1.push(e);
              }
            }
            return _results1;
          })();
          new_in_idx = (function() {
            var _len6, _p, _results1;
            _results1 = [];
            for (_p = 0, _len6 = new_in_edges.length; _p < _len6; _p++) {
              e = new_in_edges[_p];
              _results1.push(e.src.chain_idx);
            }
            return _results1;
          })();
          edges_added = edges_added.concat(in_nodes_added[id]).concat(new_in_edges);
          nodes_added[node_id] = node;
          node.slot = [Math.min.apply(null, new_in_idx), chain_minmax.outs.max];
          node.ccnum = idx;
        } else {
          if (args.verbose) {
            console.warn("Node rejected: " + node_id);
          }
        }
        if ((nodes_added[node_id] != null) && dup) {
          _ref22 = out_nodes_added[id];
          for (_p = 0, _len6 = _ref22.length; _p < _len6; _p++) {
            e = _ref22[_p];
            e.n2 = node_id;
          }
          _ref23 = in_nodes_added[id];
          for (_q = 0, _len7 = _ref23.length; _q < _len7; _q++) {
            e = _ref23[_q];
            e.n1 = node_id;
          }
        }
      }
    }
    _ref24 = j.removed_edges;
    for (_r = 0, _len8 = _ref24.length; _r < _len8; _r++) {
      e = _ref24[_r];
      if ((e != null) && ((nodes_added[e.n1] != null) && (nodes_added[e.n2] != null))) {
        if ((edge = edge_director(e.src, e.tar, e)) && (edge.src.slot[0] <= edge.tar.slot[0]) && (edge.src.slot[1] <= edge.tar.slot[1]) && ((edge.tar.slot[0] - edge.src.slot[1]) < 7) && (edge.src.ccnum === edge.tar.ccnum)) {
          edges_added.push(edge);
        }
      }
    }
    for (id in nodes_added) {
      n = nodes_added[id];
      j.nodes[id] = n;
      delete j.removed_nodes[id];
    }
    for (_s = 0, _len9 = edges_added.length; _s < _len9; _s++) {
      e = edges_added[_s];
      j.edges.push(e);
      delete j.removed_edges[e.index];
    }
    if (args.no_mp_pos_links == null) {
      remove_graph_refs(j);
      try {
        build_graph_refs(j, (function(n) {
          n.out_nodes = {};
          return n.in_nodes = {};
        }), (function(e) {
          e.src.out_nodes[e.n2] = e;
          return e.tar.in_nodes[e.n1] = e;
        }));
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      dep_edges_added = [];
      add_dep_edges = function(rank_list) {
        var new_head, new_tail, pos, prev_pos, _len10, _ref25, _results1, _t;
        rank_list.sort(function(a, b) {
          return a[0] - b[0];
        });
        new_tail = null;
        _results1 = [];
        for (_t = 0, _len10 = rank_list.length; _t < _len10; _t++) {
          _ref25 = rank_list[_t], pos = _ref25[0], new_head = _ref25[1];
          if (new_tail && (new_tail.out_nodes[new_head.id] == null) && (new_tail.in_nodes[new_head.id] == null) && pos - prev_pos > args.min_pos_diff) {
            dep_edges_added.push({
              n1: new_tail.id,
              n2: new_head.id,
              dir: "pos",
              pos_diff: pos - prev_pos
            });
          }
          new_tail = new_head;
          _results1.push(prev_pos = pos);
        }
        return _results1;
      };
      for (_t = 0, _len10 = cc_list.length; _t < _len10; _t++) {
        idx = cc_list[_t];
        chain_levels = cc_chain_levels[idx];
        for (l = _u = 0, _len11 = chain_levels.length; _u < _len11; l = ++_u) {
          n = chain_levels[l];
          base_p = 0;
          base_n = 0;
          cur_lev = {};
          pos_rank = [];
          prev = chain_levels != null ? (_ref25 = chain_levels[l - 1]) != null ? _ref25.id : void 0 : void 0;
          next = chain_levels != null ? (_ref26 = chain_levels[l + 1]) != null ? _ref26.id : void 0 : void 0;
          if (prev) {
            base_p = n.in_nodes[prev].p1;
            _ref27 = j.nodes[prev].outlinks;
            for (_v = 0, _len12 = _ref27.length; _v < _len12; _v++) {
              _ref28 = _ref27[_v], edge = _ref28[0], node = _ref28[1];
              cur_lev[edge.n2] = [edge];
            }
          }
          if (next) {
            base_n = n.out_nodes[next].p2;
            _ref29 = j.nodes[next].inlinks;
            for (_w = 0, _len13 = _ref29.length; _w < _len13; _w++) {
              _ref30 = _ref29[_w], edge = _ref30[0], node = _ref30[1];
              if ((_ref31 = cur_lev[_name5 = edge.n1]) == null) {
                cur_lev[_name5] = [];
              }
              cur_lev[edge.n1][1] = edge;
            }
          }
          for (id in cur_lev) {
            _ref32 = cur_lev[id], e_p = _ref32[0], e_n = _ref32[1];
            if (e_p && e_n && (e_p.bits + e_n.bits > args.thresh)) {
              pos = ((e_p.bits / (e_p.bits + e_n.bits)) * (e_p.p1 - base_p)) + ((e_n.bits / (e_p.bits + e_n.bits)) * (e_n.p2 - base_n));
              pos_rank.push([pos, e_p.tar]);
            } else if (e_p && (e_p.bits > args.thresh) && !(((_ref33 = j.nodes[next]) != null ? (_ref34 = _ref33.out_nodes) != null ? _ref34[e_p.tar.id] : void 0 : void 0) != null)) {
              pos = e_p.p1 - base_p;
              pos_rank.push([pos, e_p.tar]);
            } else if (e_n && (e_n.bits > args.thresh) && !(((_ref35 = j.nodes[prev]) != null ? (_ref36 = _ref35.in_nodes) != null ? _ref36[e_n.src.id] : void 0 : void 0) != null)) {
              pos = e_n.p2 - base_n;
              pos_rank.push([pos, e_n.src]);
            }
          }
          add_dep_edges(pos_rank);
        }
      }
      edge_obj = {};
      for (_x = 0, _len14 = dep_edges_added.length; _x < _len14; _x++) {
        e = dep_edges_added[_x];
        if ((_ref37 = edge_obj[_name6 = "" + e.n1 + "_" + e.n2]) == null) {
          edge_obj[_name6] = 0;
        }
        edge_obj["" + e.n1 + "_" + e.n2]++;
      }
      for (_y = 0, _len15 = dep_edges_added.length; _y < _len15; _y++) {
        e = dep_edges_added[_y];
        if (!(edge_obj["" + e.n2 + "_" + e.n1] || --edge_obj["" + e.n1 + "_" + e.n2])) {
          good = true;
          _ref38 = j.nodes[e.n2].outlinks;
          for (_z = 0, _len16 = _ref38.length; _z < _len16; _z++) {
            _ref39 = _ref38[_z], edge = _ref39[0], node = _ref39[1];
            if (!node.out_nodes[e.n1]) {
              continue;
            }
            good = false;
            break;
          }
          if (good) {
            j.edges.push(e);
          }
        }
      }
    }
    remove_graph_refs(j, function(n) {
      delete n.in_nodes;
      delete n.out_nodes;
      delete n.ccnum;
      delete n.cclen;
      delete n.chain_idx;
      return delete n.slot;
    });
    delete j.connected_comps;
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Layout scaffolds
  */


  scaffold = function(j, args, callback) {
    var all_scaffs, all_tsort, c, cci, ccomp_ends, e, edge, ei, end_id, i, id, in_keys, in_node, in_scaffs, len_to, longest_chain, max_id, max_len, n, n2, node, out_node, prev, remove_cands, scaf_name, sink_nodes, source_nodes, tsort, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _ref, _ref1, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Lay out a fully linear scaffold from contigs in unambiguously ordered\n         connected components");
      if (args.detailed_help != null) {
        console.warn("\nParameters: NONE.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.scaffolds != null) {
      delete j.scaffolds;
      if (j.clusters != null) {
        delete j.clusters;
      }
    }
    if (j.connected_comps == null) {
      calc_ccomps(j);
    }
    try {
      ccomp_ends = find_all_ends(j);
      build_graph_refs(j, (function(n) {
        return n.in_edges = {};
      }), (function(e) {
        return e.tar.in_edges[e.src.id] = e;
      }));
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    all_tsort = [];
    all_scaffs = [];
    in_scaffs = {};
    for (cci = _i = 0, _len = ccomp_ends.length; _i < _len; cci = ++_i) {
      _ref = ccomp_ends[cci], source_nodes = _ref[0], sink_nodes = _ref[1];
      tsort = [];
      for (_j = 0, _len1 = source_nodes.length; _j < _len1; _j++) {
        n = source_nodes[_j];
        n.in_edges = {};
      }
      while (n = source_nodes.pop()) {
        tsort.push(n.id);
        _ref1 = n.outlinks;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          e = _ref1[_k];
          delete e[1].in_edges[n.id];
          if (Object.keys(e[1].in_edges).length === 0) {
            source_nodes.push(e[1]);
          }
        }
        if (args.rescue && (source_nodes.length === 0) && (tsort.length !== j.connected_comps[cci].length)) {
          remove_cands = (function() {
            var _l, _len3, _ref2, _results;
            _ref2 = j.connected_comps[cci];
            _results = [];
            for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
              id = _ref2[_l];
              if ((tsort.indexOf(id) === -1) && ((in_keys = Object.keys(j.nodes[id].in_edges)).length === 1) && (j.nodes[id].in_edges[in_keys[0]].pos_diff != null)) {
                _results.push([j.nodes[id], j.nodes[in_keys[0]]]);
              }
            }
            return _results;
          })();
          if (remove_cands.length) {
            remove_cands.sort(function(a, b) {
              return a[0].in_edges[a[1].id].pos_diff - b[0].in_edges[b[1].id].pos_diff;
            });
            _ref2 = remove_cands[0], in_node = _ref2[0], out_node = _ref2[1];
            console.warn("Rescuing node " + remove_cands[0][0].id + ": position dependent edge from " + remove_cands[0][1].id);
            _ref3 = out_node.outlinks;
            for (ei = _l = 0, _len3 = _ref3.length; _l < _len3; ei = ++_l) {
              edge = _ref3[ei];
              if (!(edge[0] === in_node.in_edges[out_node.id])) {
                continue;
              }
              out_node.outlinks.splice(ei, 1);
              break;
            }
            delete in_node.in_edges[out_node.id];
            source_nodes.push(in_node);
          }
        }
      }
      all_tsort.push(tsort);
      len_to = {};
      max_id = tsort[0];
      max_len = j.nodes[max_id].seq_len;
      for (_m = 0, _len4 = tsort.length; _m < _len4; _m++) {
        id = tsort[_m];
        n = j.nodes[id];
        if ((_ref4 = len_to[id]) == null) {
          len_to[id] = {
            len: n.seq_len,
            edge: null
          };
        }
        _ref5 = n.outlinks;
        for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
          _ref6 = _ref5[_n], e = _ref6[0], n2 = _ref6[1];
          if (!((len_to[n2.id] == null) || (len_to[n2.id].len < len_to[id].len + n2.seq_len))) {
            continue;
          }
          len_to[n2.id] = {
            len: len_to[id].len + n2.seq_len,
            edge: e
          };
          if (len_to[n2.id].len > max_len) {
            max_id = n2.id;
            max_len = len_to[n2.id].len;
          }
        }
      }
      longest_chain = [j.nodes[max_id]];
      if ((_ref7 = len_to[max_id].edge) != null) {
        _ref7.keep = true;
      }
      prev = len_to[max_id];
      while (prev.edge != null) {
        longest_chain.unshift(prev.edge.src);
        prev.edge.keep = true;
        prev = len_to[prev.edge.src.id];
      }
      for (i = _o = 0, _len6 = longest_chain.length; _o < _len6; i = ++_o) {
        n = longest_chain[i];
        all_scaffs.push(n.id);
        in_scaffs[n.id] = i;
      }
      if (sink_nodes.indexOf(longest_chain[longest_chain.length - 1]) === -1) {
        end_id = longest_chain[longest_chain.length - 1].id;
        console.warn("Scaffold Warning: CCOMP " + cci + " was not completely traversed. " + end_id + " " + ((100.0 * (tsort.length / j.connected_comps[cci].length)).toFixed(1)) + "% " + ((100.0 * (longest_chain.length / j.connected_comps[cci].length)).toFixed(1)) + "% ");
      }
    }
    _ref8 = j.edges;
    for (_p = 0, _len7 = _ref8.length; _p < _len7; _p++) {
      e = _ref8[_p];
      if (!(e.keep == null)) {
        continue;
      }
      j.removed_edges.push(e);
      delete j.edges[e.index];
    }
    _ref9 = j.nodes;
    for (id in _ref9) {
      n = _ref9[id];
      if (!(in_scaffs[id] == null)) {
        continue;
      }
      j.removed_nodes[id] = n;
      delete j.nodes[id];
    }
    remove_graph_refs(j, function(n) {
      delete n.in_edges;
      return delete n.saved_outlinks;
    }, function(e) {
      return delete e.keep;
    });
    calc_ccomps(j);
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    j.scaffolds = {};
    _ref10 = j.connected_comps;
    for (i = _q = 0, _len8 = _ref10.length; _q < _len8; i = ++_q) {
      c = _ref10[i];
      scaf_name = "Scaffold_" + i;
      j.scaffolds[scaf_name] = {
        "ccnum": i,
        "nodes": []
      };
      try {
        node = find_ends(j, c, true)[0][0];
      } catch (err) {
        if (typeof callback === "function") {
          callback(err, null);
        }
        return;
      }
      while (node) {
        if (node.recon_seq != null) {
          j.scaffolds[scaf_name].nodes.push(node.id);
        }
        node = (_ref11 = node.outlinks[0]) != null ? _ref11[1] : void 0;
      }
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Make explicit edits to the current assembly graph
  */


  perform_edits = function(j, args, callback) {
    var e, n2_list, nid, nid1, type, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Make manual explicit edits to the selected graph structure");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nrem_nodes : [\"contig1\",\"contig2\",...] -- Remove the specified contig nodes by name\n\n        Example: " + args.help + " {\"rem_nodes\":[\"NODE_1234\",\"NODE_5678\"]} -- Remove\n        these two contigs from the graph\n\nadd_nodes : [\"contig1\",\"contig2\",...] -- Add back the specified contig nodes by name\n\n        Example: " + args.help + " {\"add_nodes\":[\"NODE_1234\",\"NODE_5678\"]} -- Move\n        these two contigs from the removed pool to the selected graph\n\nrem_edges : [\"contig1\",[\"contig2\",...]] -- Remove the specified connections between\n        contig1 and any number of others.\n\n        Example: " + args.help + " {\"rem_edges\":[\"NODE_1234\",[\"NODE_5678\",\"NODE_9\"]]}\n        -- Remove two connection edges from the graph, both connected to NODE_1234\n\nadd_edges : [\"contig1\",[\"contig2\",...]] -- Add back the specified connections between\n        contig1 and any number of others.\n\n        Example: " + args.help + " {\"add_edges\":[\"NODE_1234\",[\"NODE_5678\",\"NODE_9\"]]}\n        -- Add two connection edges from the graph, both connected to NODE_1234\n\n        NOTE: for rem_edges and add_edges above, if only a single edge is involved, then\n        the parameter syntax may optionally be flattened. For example:\n        {\"add_edges\":[\"NODE_1234\",[\"NODE_9\"]]} is equivalent to\n        {\"add_edges\":[\"NODE_1234\",\"NODE_9\"]}\n\n        If more than one node-independent sets of edges are to be added or removed (that\n        is, those not sharing any contig(s) in common), then multiple calls to ${args.help}\n        are required to accomplish this task.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if ((_ref = args.rem_nodes) == null) {
      args.rem_nodes = [];
    }
    if ((_ref1 = args.rem_edges) == null) {
      args.rem_edges = [];
    }
    if ((_ref2 = args.add_nodes) == null) {
      args.add_nodes = [];
    }
    if ((_ref3 = args.add_edges) == null) {
      args.add_edges = [];
    }
    type = (function() {
      var classToType, name, _i, _len, _ref4;
      classToType = {};
      _ref4 = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        name = _ref4[_i];
        classToType["[object " + name + "]"] = name.toLowerCase();
      }
      return function(obj) {
        var strType;
        strType = Object.prototype.toString.call(obj);
        return classToType[strType] || "object";
      };
    })();
    _ref4 = args.add_nodes;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      nid = _ref4[_i];
      if (!(j.removed_nodes[nid] != null)) {
        continue;
      }
      console.warn("EDIT: Adding node " + nid);
      j.nodes[nid] = j.removed_nodes[nid];
      delete j.removed_nodes[nid];
    }
    _ref5 = args.add_edges;
    for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
      _ref6 = _ref5[_j], nid1 = _ref6[0], n2_list = _ref6[1];
      if (!(j.nodes[nid1] != null)) {
        continue;
      }
      if (type(n2_list) === "string") {
        n2_list = [n2_list];
      }
      _ref7 = j.nodes[nid1].rem_links;
      for (_k = 0, _len2 = _ref7.length; _k < _len2; _k++) {
        e = _ref7[_k];
        if (!((n2_list.indexOf(e[1].id) !== -1) && (j.removed_edges[e[0].index] != null))) {
          continue;
        }
        console.warn("EDIT: Adding edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.removed_edges[e[0].index].n1 + " --> " + j.removed_edges[e[0].index].n2);
        delete j.removed_edges[e[0].index];
        e[0].index = j.edges.push(e[0]) - 1;
      }
    }
    _ref8 = args.rem_nodes;
    for (_l = 0, _len3 = _ref8.length; _l < _len3; _l++) {
      nid = _ref8[_l];
      if (!(j.nodes[nid] != null)) {
        continue;
      }
      console.warn("EDIT: Deleting node " + nid);
      _ref9 = j.nodes[nid].links;
      for (_m = 0, _len4 = _ref9.length; _m < _len4; _m++) {
        e = _ref9[_m];
        if (!(j.edges[e[0].index] != null)) {
          continue;
        }
        console.warn("EDIT: Removing edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.edges[e[0].index].n1 + " --> " + j.edges[e[0].index].n2);
        delete j.edges[e[0].index];
        e[0].index = j.removed_edges.push(e[0]) - 1;
      }
      j.removed_nodes[nid] = j.nodes[nid];
      delete j.nodes[nid];
    }
    _ref10 = args.rem_edges;
    for (_n = 0, _len5 = _ref10.length; _n < _len5; _n++) {
      _ref11 = _ref10[_n], nid1 = _ref11[0], n2_list = _ref11[1];
      if (!(j.nodes[nid1] != null)) {
        continue;
      }
      if (type(n2_list) === "string") {
        n2_list = [n2_list];
      }
      _ref12 = j.nodes[nid1].links;
      for (_o = 0, _len6 = _ref12.length; _o < _len6; _o++) {
        e = _ref12[_o];
        if (!((n2_list.indexOf(e[1].id) !== -1) && (j.edges[e[0].index] != null))) {
          continue;
        }
        console.warn("EDIT: Removing edge " + e[0].n1 + " --> " + e[0].n2 + " Index: " + e[0].index + " " + j.edges[e[0].index].n1 + " --> " + j.edges[e[0].index].n2);
        delete j.edges[e[0].index];
        e[0].index = j.removed_edges.push(e[0]) - 1;
      }
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # create new nodes from parts of the given nodes
  */


  cut_node = function(j, args, callback) {
    var e, k, new_node, node, p, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Create a new node from an existing node using the given coordinates");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nname : \"contig_name\" -- Name of the contig node to be copied\n\n        Example: " + args.help + " {\"name\":\"NODE_1234\"} -- Use sequence from NODE_1234\n\nnew_name : \"new_contig_name\" -- Name for the newly created contig node\n\n        Example: " + args.help + " {\"new_name\":\"NODE_1234a\"} -- New node will be named\n        NODE_1234a\n\nstart : <int> -- Beginning sequence coordinate for the new node within the original\nend : <int> -- Ending sequence coordinate for the new node within the original\n\n        Example: " + args.help + " {\"start\":123,\"end\":456} -- The new node will include\n        sequence from positions 123 to 456\n\n        Example: " + args.help + " {\"end\":456} -- The new node will include sequence from\n        position 0 (implied) to 456. end may also be omitted, implying the last position\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    try {
      build_graph_refs(j);
      build_removed_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    node = j.nodes[args.name];
    new_node = {};
    if (!node) {
      if (typeof callback === "function") {
        callback(new Error('CUTND requires a valid node "name" argument.'), null);
      }
      return;
    }
    if ((_ref = args.start) == null) {
      args.start = 0;
    }
    if ((_ref1 = args.end) == null) {
      args.end = node.seq_len - 1;
    }
    if (!(args.start < args.end && args.end < node.seq_len)) {
      if (typeof callback === "function") {
        callback(new Error('CUTND requires valid "start" and "end" arguments.'), null);
      }
      return;
    }
    k = 1;
    if ((_ref2 = args.new_name) == null) {
      args.new_name = ((function() {
        while (j.nodes[node.name + "_Cut_" + k] != null) {
          k++;
        }
        return node.name + "_Cut_" + k;
      })());
    }
    j.nodes[args.new_name] = new_node;
    console.warn("CUTND: Adding " + args.new_name + " from " + args.start + " - " + args.end + " of " + node.name);
    for (p in node) {
      new_node[p] = node[p];
    }
    new_node.name = args.new_name;
    new_node.id = args.new_name;
    new_node.seq_len = args.end - args.start + 1;
    delete new_node.contig_problems;
    if (new_node.per_nt_cov != null) {
      new_node.per_nt_cov = new_node.per_nt_cov.slice(args.start, args.end);
    }
    if (new_node.per_nt_phys_cov != null) {
      new_node.per_nt_phys_cov = new_node.per_nt_phys_cov.slice(args.start, args.end);
    }
    if (new_node.per_nt_mp_ins != null) {
      new_node.per_nt_mp_ins = new_node.per_nt_mp_ins.slice(args.start, args.end);
    }
    if (new_node.recon_seq != null) {
      new_node.recon_seq = new_node.recon_seq.substring(args.start, args.end);
    }
    _ref3 = new_node.inlinks;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      e = _ref3[_i];
      if (!(e[0].p2 >= args.start && e[0].p2 <= args.end && ((_ref4 = args.include) != null ? _ref4.indexOf(e[1].id) : void 0) !== -1)) {
        continue;
      }
      console.warn("CUTND: Moving edge " + e[0].n1 + " --> " + e[0].n2 + " to " + args.new_name);
      e[0].n2 = args.new_name;
      e[0].p2 = e[0].p2 - args.start;
    }
    _ref5 = new_node.outlinks;
    for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
      e = _ref5[_j];
      if (!(e[0].p1 >= args.start && e[0].p1 <= args.end && ((_ref6 = args.include) != null ? _ref6.indexOf(e[1].id) : void 0) !== -1)) {
        continue;
      }
      console.warn("CUTND: Moving edge " + e[0].n1 + " --> " + e[0].n2 + " to " + args.new_name);
      e[0].n1 = args.new_name;
      e[0].p1 = e[0].p1 - args.start;
    }
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # Report on problem contigs
  */


  node_problems = function(j, args, callback) {
    var count, min, name, node, node_cnt, o, pos, prob_types, problem, total, type, x, _i, _j, _len, _name, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Generate a report of contigs with likely internal assembly issues");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.txt[.gz]\" -- name of txt format file to write statistics to\n\n        Example: " + args.help + " {\"file\":\"problems.txt\"} -- Write report to the file\n        problems.txt\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Default. Write report to STDOUT\n\ndetail : true -- Provide extra per contig detail\n\n        Example: " + args.help + " {\"detail\":true}\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if ((_ref = args.detail) == null) {
      args.detail = false;
    }
    node_cnt = 0;
    total = 0;
    prob_types = {};
    _ref1 = j.nodes;
    for (name in _ref1) {
      node = _ref1[name];
      if (!(node.contig_problems != null)) {
        continue;
      }
      if (args.detail) {
        o.write("" + name + "\t" + node.contig_problems.length + "\n");
      }
      node_cnt++;
      _ref2 = node.contig_problems;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        problem = _ref2[_i];
        total++;
        if ((_ref3 = prob_types[_name = problem.type]) == null) {
          prob_types[_name] = 0;
        }
        prob_types[problem.type]++;
        if (args.detail) {
          if (problem.type === "Physical coverage break") {
            if (node.per_nt_phys_cov != null) {
              min = node.per_nt_phys_cov[problem.start];
              pos = problem.start;
              for (x = _j = _ref4 = problem.end, _ref5 = problem.start; _ref4 <= _ref5 ? _j < _ref5 : _j > _ref5; x = _ref4 <= _ref5 ? ++_j : --_j) {
                if (!(node.per_nt_phys_cov[x] < min)) {
                  continue;
                }
                min = node.per_nt_phys_cov[x];
                pos = x;
              }
            }
            o.write("\t" + problem.type + "\t" + problem.start + "\t" + problem.end + "\t" + pos + "\n");
          } else {
            o.write("\t" + problem.type + "\t" + problem.start + "\t" + problem.end + "\n");
          }
        }
      }
    }
    o.write("\nProblem nodes: " + node_cnt + "\n");
    o.write("Total problems: " + total + "\n");
    o.write("Problem breakdown:\n");
    for (type in prob_types) {
      count = prob_types[type];
      o.write("\t" + type + ": " + count + "\n");
    }
    return close_output_stream(o, function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  # Invoke tetracalc on current scaffolds, gather results
  */


  tetracalc = function(j, args, callback) {
    var cluster_json, options, tet;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Cluster scaffolds using the tetracalc tool");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\noptions : <string> -- Command line options for the tetracalc tool. Otherwise defaults used.\n\n        NOTE: Run with --help for help with the settings offered by tetracalc.\n\n        Example: " + args.help + " {\"options\":\"--merge_tar=0.95 -m 7500\"}\n\n        Example: " + args.help + " {\"options\":\"--help\"}\n\n        Example: " + args.help + " {\"options\":\"--fixed -t 0.9 -s 0.8 -r 0.9\"}\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.scaffolds == null) {
      if (typeof callback === "function") {
        callback(new Error("No valid scaffolds found. Run SCAFF first."), null);
      }
      return;
    }
    if (!(Object.keys(j.scaffolds).length > 1)) {
      if (typeof callback === "function") {
        callback(new Error("There must be at least two scaffolds to run CLUST."), null);
      }
      return;
    }
    console.warn("CLUST: invoking tetracalc tool");
    cluster_json = "";
    if (args.options) {
      options = args.options.split('\s+');
      options.push('-');
    } else {
      options = ['-'];
    }
    tet = child_process.spawn('tetracalc', options, {});
    tet.stdout.setEncoding('ascii');
    tet.stderr.setEncoding('ascii');
    tet.stdout.on('data', function(data) {
      return cluster_json = cluster_json.concat(data);
    });
    tet.stderr.on('data', function(data) {
      return process.stderr.write(data);
    });
    tet.stdout.on('end', function() {
      try {
        j.clusters = JSON.parse(cluster_json).clusters;
      } catch (err) {
        if (typeof callback === "function") {
          callback(new Error("Failed to parse output of tetracalc program. " + err.message), null);
        }
        return;
      }
      return typeof callback === "function" ? callback(null, j) : void 0;
    });
    tet.on('exit', function(code) {
      if (code) {
        console.error('ERROR: ' + code);
        return typeof callback === "function" ? callback(new Error('SEAStAR program "tetracalc" could not be executed. Please ensure that it is in your PATH'), null) : void 0;
      }
    });
    return export_fasta(j, {
      "scaff": true,
      "merge_scaffs": true,
      "stream": tet.stdin,
      "verbose": args.verbose
    });
  };

  /*
  # Select clusters for output or further processing
  #
  # args (mutually exclusive):
  #
  # clustnum : Choose a cluster by number
  # clustnums : Choose a list of clusters
  # clustrange : Choose multiple clusters by a range of numbers 
  #
  */


  grab_clusts = function(j, args, callback) {
    var cl, new_cclist, new_clusts, new_scaffs, scaf_id, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _results;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Select clusters of scaffolds for further processing");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nclustnum : <int> -- Select a specific cluster\n\n        Example: " + args.help + " '{\"clustnum\":0}' -- select the first cluster\n\nclustnums : [<int1>, <int2>, ...] -- Select specific clusters\n\n        Example: " + args.help + " '{\"clustnums\":[0,3,5]}' -- select these three clusters\n\nclustrange : [<int1>, <int2>] -- Select a range of clusters\n\n        Example: " + args.help + " '{\"clustrange\":[0,5]}' -- select the first six clusters\n\n        Example: " + args.help + " '{\"clustrange\":[-5,-1]}' -- select the last five clusters\n\n        Example: " + args.help + " '{\"clustrange\":[0,-2]}' -- select all clusters except the\n        last one\n\nexclusive : true -- Remove all scaffolds outside of the selected clusters\n\n        Example: " + args.help + " '{\"exclusive\":false}' -- Default. Keep all unselected scaffolds.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (j.clusters == null) {
      if (typeof callback === "function") {
        callback(new Error("No valid scaffold clusters found. Run CLUST first."), null);
      }
      return;
    }
    try {
      build_graph_refs(j);
    } catch (err) {
      if (typeof callback === "function") {
        callback(err, null);
      }
      return;
    }
    if (args.clustnum != null) {
      args.clustnums = [args.clustnum];
    } else if (args.clustrange != null) {
      if (args.clustrange[0] < 0) {
        args.clustrange[0] = j.clusters.length + args.clustrange[0];
      }
      if (args.clustrange[1] < 0) {
        args.clustrange[1] = j.clusters.length + args.clustrange[1];
      }
      args.clustnums = (function() {
        _results = [];
        for (var _i = _ref = args.clustrange[0], _ref1 = args.clustrange[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; _ref <= _ref1 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
    } else {
      if ((_ref2 = args.clustnums) == null) {
        args.clustnums = [0];
      }
    }
    new_cclist = [];
    new_clusts = [];
    new_scaffs = {};
    _ref3 = args.clustnums;
    for (_j = 0, _len = _ref3.length; _j < _len; _j++) {
      cl = _ref3[_j];
      if (j.clusters[cl] == null) {
        if (typeof callback === "function") {
          callback(new Error("Invalid selected clustnum: " + cl + ".  clustnums are zero-based and there are only " + j.clusters.length + " clusters in this graph."), null);
        }
        return;
      }
      new_clusts.push(j.clusters[cl]);
      _ref4 = j.clusters[cl];
      for (_k = 0, _len1 = _ref4.length; _k < _len1; _k++) {
        scaf_id = _ref4[_k];
        if (args.exclusive) {
          new_cclist.push(j.scaffolds[scaf_id].ccnum);
        }
        new_scaffs[scaf_id] = j.scaffolds[scaf_id];
      }
    }
    if (args.exclusive) {
      grab_ccomps(j, {
        "ccnums": new_cclist
      });
    }
    j.clusters = new_clusts;
    j.scaffolds = new_scaffs;
    remove_graph_refs(j);
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # DUMP -- Output current JSON structure to a file
  #
  # args:
  #
  # file : Filename to write
  #
  */


  write_json = function(j, args, callback) {
    var o;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Output current data structure to a file, or by default to STDOUT");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.json[.gz]\" -- Specify a file name to write the JSON format sequence graph to.\n\n        If the filename contains one or more `#` characters in a row, these positions are\n        replaced with zero-padded digits that will increment each time a file is written to\n        this filename pattern. If no `#` characters are present, then this command overwrites\n        any existing file of the same name.\n\n        Example: " + args.help + " {\"file\":\"my_assembly.json\"} -- Write data to the file\n        my_assembly.json\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Write data piped to STDOUT (default)\n\n        Example: " + args.help + " {\"file\":\"my_assembly_###.json\"} -- Write data to the file:\n        my_assembly_000.json (first time this is run)\n\n        Example: " + args.help + " {\"file\":\"my_assembly_###.json\"} -- Run again, write data\n        to the file: my_assembly_001.json\n ");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    o = open_output_stream(args.file);
    if (!o) {
      if (typeof callback === "function") {
        callback(new Error("open_output_stream could not open file '" + args.file + "' for output."), null);
      }
      return;
    } else {
      o.on("error", function(err) {
        console.error("ERROR: open_output_stream could not write to file '" + args.file + "'.");
        return typeof callback === "function" ? callback(err, null) : void 0;
      });
    }
    if (args.pretty != null) {
      o.write(JSON.stringify(j, null, 1));
    } else {
      my_stringify(j, o);
    }
    return close_output_stream(o, function(error) {
      if (error) {
        return typeof callback === "function" ? callback(error, null) : void 0;
      } else {
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  # read_json -- 
  #
  # args:
  #
  # file : Filename to read
  #
  */


  read_json = function(j, args, callback) {
    if (args == null) {
      args = {
        'file': '-'
      };
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Input JSON sequence graph data from a file, or by default from STDIN.");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename.json[.gz]\" -- Specify the name of a JSON format sequence graph file\n\n        Example: " + args.help + " {\"file\":\"my_assembly.json\"} -- Read data from the file\n        my_assembly.json\n\n        Example: " + args.help + " {\"file\":\"-\"} -- Read data piped from STDIN (default)\n\n        NOTE: On the command line, if the first parameter isn't a valid command string,\n        and it ends in `.json[.gz]`, then it is assmued to be the name of a JSON file,\n        and an implicit `LOAD` command will be run using that filename.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    return read_input_stream(args.file, function(error, read_buffer) {
      var _ref;
      if (error || !read_buffer) {
        console.error("ERROR: Empty buffer returned for file: " + args.file);
        if (typeof callback === "function") {
          callback(error || new Error("Empty buffer returned for file: " + args.file), null);
        }
      } else {
        try {
          j = JSON.parse(read_buffer);
        } catch (err) {
          console.error("ERROR: Problem parsing JSON data file " + args.file);
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        read_buffer = null;
        if ((_ref = j.processing) == null) {
          j.processing = [];
        }
        j.processing.push(["$", ss_version, 'LOAD', clone_object(args)]);
        return typeof callback === "function" ? callback(null, j) : void 0;
      }
    });
  };

  /*
  # command_file -- Implementation of the SCRIPT command
  */


  command_file = function(j, args, callback) {
    var queue_commands;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Use contents of file as a series of commands, or read from the console if\n          no file provided");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\nfile : \"filename[.gz]\" -- Read commands from the named file\n\n        Example: " + args.help + " {\"file\":\"my_script.txt\"} -- Read and run commands from\n        the file my_script.txt\n\n        Example: " + args.help + " -- Enter an interactive (command line) session at this point\n        typing commands one at a time\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    queue_commands = function(error, read_buffer) {
      var argstr, cmd, cmd_args, l, lines, script_cmds, script_next_cmd, _i, _len, _ref;
      if (error || !read_buffer) {
        if (typeof callback === "function") {
          callback(error || new Error("empty read_buffer after reading SCRIPT file."), null);
        }
        return;
      }
      lines = read_buffer.split("\n");
      script_cmds = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        _ref = l.trim().replace(/\t/, " ").split(" ", 2), cmd = _ref[0], argstr = _ref[1];
        cmd = cmd.toUpperCase();
        if (typeof commands[cmd] === 'function') {
          if (argstr) {
            try {
              cmd_args = JSON.parse(argstr);
            } catch (err) {
              console.error("ERROR: Could not parse JSON arguments '" + argstr + "' to '" + cmd + "' command");
              if (typeof callback === "function") {
                callback(err, null);
              }
              return;
            }
          } else {
            cmd_args = null;
          }
          if ((cmd === 'SCRIPT') && ((cmd_args != null ? cmd_args.file : void 0) == null)) {
            if (typeof callback === "function") {
              callback(new Error("Invalid command: You may not launch an interactive SCRIPT session from within a SCRIPT."), null);
            }
            return;
          } else {
            script_cmds.push([commands[cmd], cmd_args, cmd]);
          }
        } else if (cmd && cmd[0] !== '#') {
          if (typeof callback === "function") {
            callback(new Error("Invalid command: '" + cmd + "'"), null);
          }
          return;
        }
      }
      read_buffer = null;
      script_next_cmd = function(err, j) {
        var cmd_func, _ref1, _ref2;
        if (err) {
          console.error("ERROR terminating SCRIPT processing: " + err.message + "\n");
          if (typeof callback === "function") {
            callback(err, null);
          }
          return;
        }
        if (script_cmds.length) {
          _ref1 = script_cmds.shift(), cmd_func = _ref1[0], cmd_args = _ref1[1], cmd = _ref1[2];
          if (!(((j != null ? j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH' || cmd === 'HELP')) {
            if (typeof callback === "function") {
              callback(new Error("No data, ending SCRIPT processing."), null);
            }
            return;
          }
          if (cmd !== 'HELP') {
            if (j != null) {
              if ((_ref2 = j.processing) != null) {
                _ref2.push([args.file, ss_version, cmd, clone_object(cmd_args)]);
              }
            }
          }
          console.warn("Executing (" + args.file + ") " + cmd + " " + (JSON.stringify(cmd_args)));
          return cmd_func(j, cmd_args, script_next_cmd);
        } else {
          return typeof callback === "function" ? callback(null, j) : void 0;
        }
      };
      return script_next_cmd(null, j);
    };
    if (args.file != null) {
      return read_input_stream(args.file, queue_commands);
    } else {
      if (!((process.stderr._type != null) && process.stderr._type === 'tty')) {
        console.log("ERROR: Interactive use of the SCRIPT command requires that STDERR not be redirected.\n");
        if (typeof callback === "function") {
          callback(new Error("Interactive use of the SCRIPT command requires that STDERR not be redirected."), null);
        }
        return;
      }
      console.warn("\nEntering interactive SCRIPT mode, SEAStAR Version: " + ss_version + "\nFor general help, quit and rerun with the -h option. Type 'HELP' for help with commands.\nType '.save <filename>' to save commands from this session to an output file.\nPress <Ctrl-D> to quit.\n");
      if ((process.stdout._type != null) && process.stdout._type !== 'tty') {
        console.warn("NOTE: You appear to be redirecting the output of this session, no interactive command results will be visible.\n");
      }
      return repl.start({
        prompt: ">> ",
        output: process.stderr,
        input: process.stdin,
        terminal: true,
        ignoreUndefined: true,
        "eval": function(l, cx, fn, cb) {
          var arg_json, argstr, cmd, cmd_func, _ref, _ref1;
          _ref = l.slice(1, -1).trim().replace(/\t|\n/, " ").split(" ", 2), cmd = _ref[0], argstr = _ref[1];
          cmd = cmd.toUpperCase();
          if (cmd === 'HELP') {
            cmd_func = commands[cmd];
            if (argstr != null ? argstr.match(/{.*}/) : void 0) {
              try {
                arg_json = JSON.parse(argstr);
              } catch (err) {
                console.error("\nERROR: Could not parse JSON arguments '" + argstr + "' to '" + cmd + "' command\n");
                cb(null, void 0);
                return;
              }
              return cmd_func(j, arg_json, function(j) {
                return cb(null, void 0);
              });
            } else {
              return cmd_func(j, {
                'topic': argstr
              }, function(j) {
                return cb(null, void 0);
              });
            }
          } else if (typeof commands[cmd] === 'function') {
            if (argstr) {
              try {
                args = JSON.parse(argstr);
              } catch (err) {
                console.warn("\nInvalid arguments '" + argstr + "' to '" + cmd + "'. Could not parse JSON string.\n");
                cb(null, void 0);
                return;
              }
            } else {
              args = null;
            }
            if ((cmd === 'SCRIPT') && ((args != null ? args.file : void 0) == null)) {
              console.warn("\nInvalid command: You may not launch nested interactive SCRIPT sessions.\n");
              return cb(null, void 0);
            } else if (!((((j != null ? j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH') || cmd === 'HELP')) {
              console.warn("\nError: No data is currently loaded. Use the LOAD command to read a datafile\n");
              return cb(null, void 0);
            } else {
              cmd_func = commands[cmd];
              if (j != null) {
                if ((_ref1 = j.processing) != null) {
                  _ref1.push([">>", ss_version, cmd, clone_object(args)]);
                }
              }
              return cmd_func(j, args, function(err, return_j) {
                if (err || !return_j) {
                  console.error("ERROR: " + err.message + "\n");
                  console.warn("\nCommand failed: Please examine the above error messages and try again.\n");
                } else {
                  j = return_j;
                }
                return cb(null, void 0);
              });
            }
          } else {
            if (cmd) {
              console.warn("\nInvalid command: '" + cmd + "'\n");
            }
            return cb(null, void 0);
          }
        }
      }).on('exit', function() {
        console.warn("\n");
        return typeof callback === "function" ? callback(null, j) : void 0;
      });
    }
  };

  /*
  # output_help -- Implementation of the HELP command
  */


  output_help = function(j, args, callback) {
    var c, cmd_list;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- List all valid commands, or provide detailed help for a specific command\n        with " + args.help + " <COMMAND>");
      if (args.detailed_help != null) {
        console.warn("\nParameters:\n\ntopic : \"command\" -- Provide detailed help for a specific command.\n\n        Example: " + args.help + " {\"topic\":\"" + args.help + "\"} -- Provide help about the\n        " + args.help + " command itself\n\n        Using the special word 'ALL' (which is not a valid command) in place of the\n        command string will cause detailed help to be printed for all commands.\n\n        Example: " + args.help + " {\"topic\":\"ALL\"} -- Provide detail help about commands\n\n        NOTE: The " + args.help + " command when used as the first and only command on the\n        command-line (or within an interactive SCRIPT session) may include the topic\n        command directly as the second command line parameter\n\n        Example: " + args.help + " " + args.help + " is equivalent to " + args.help + " {\"topic\":\"" + args.help + "\"} in this situation\n\ncmd_line : true -- Provide detailed help for UNIX shell command line use.\n\n        Example: " + args.help + " {\"cmd_line\":\"true\"} -- UNIX command line help.\n\n        This help can also be obtained from the shell by running with the -h option.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    cmd_list = function() {
      var c;
      for (c in commands) {
        if (typeof commands[c] === 'function') {
          commands[c](j, {
            'help': c
          });
        } else {
          console.warn(commands[c]);
        }
      }
      return console.warn('');
    };
    if (args.topic != null) {
      args.topic = args.topic.toUpperCase();
      if (typeof commands[args.topic] === 'function') {
        console.warn('');
        commands[args.topic](j, {
          'help': args.topic,
          'detailed_help': true
        });
      } else if (args.topic.toUpperCase() === 'ALL') {
        cmd_list();
        for (c in commands) {
          if (typeof commands[c] === 'function') {
            console.warn('==========================================================================================\n');
            commands[c](j, {
              'help': c,
              'detailed_help': true
            });
          }
        }
      } else {
        console.warn("\nCommand '" + args.topic + "' not found, please select a valid command from below:\n");
        cmd_list();
      }
    } else if (args.cmd_line != null) {
      console.warn("" + commands['prelude1'] + "\nUsage: graph_ops [<input.json[.gz]>] [<script.go[.gz]>] [<command> ['{params}']]...\n\nwhere: <input.json[.gz]> is an optional datafile to initially LOAD\n       <script.go[.gz]> is an optional SCRIPT to initially execute\n       <command> is a valid command (see below)\n       '{params}' optionally specify parameters for a given command\n\nMultiple commands with optional parameters may be provided in succession for execution.\n\nRunning this program without any options will launch an interactive mode,\nequivalent to:  graph_ops SCRIPT\n  \nFor a list of valid commands: use: graph_ops HELP\n\nFor detailed help for a specific command, use: graph_ops HELP <command>\n\nSEAStAR Version: " + ss_version + "\n");
    } else {
      cmd_list();
    }
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # push_stash --
  */


  push_stash = function(j, args, callback) {
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Copy (push) the current graph to the top of a stack in memory");
      if (args.detailed_help != null) {
        console.warn("\nParameters:  None.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    stash_stack.push(clone_object(j));
    console.warn("" + stash_stack.length + " graph" + (stash_stack.length !== 1 ? 's' : '') + " in stash.");
    return typeof callback === "function" ? callback(null, j) : void 0;
  };

  /*
  # pop_stash --
  */


  pop_stash = function(j, args, callback) {
    var hist;
    if (args == null) {
      args = {};
    }
    if (args.help != null) {
      console.warn("" + args.help + " -- Restore (pop) the current graph from the top of the stack (undo changes) ");
      if (args.detailed_help != null) {
        console.warn("\nParameters:  None.\n");
      }
      if (typeof callback === "function") {
        callback(null, j);
      }
      return;
    }
    if (!(stash_stack.length > 0)) {
      if (typeof callback === "function") {
        callback(new Error("UNSTASH failed, stash is empty."), null);
      }
    } else {
      hist = j.processing || [];
      j = stash_stack.pop();
      j.processing = hist;
      console.warn("" + stash_stack.length + " graph" + (stash_stack.length !== 1 ? 's' : '') + " remain" + (stash_stack.length === 1 ? 's' : '') + " in stash.");
      return typeof callback === "function" ? callback(null, j) : void 0;
    }
  };

  /*
  # ************************************************************************
  # Mapping of command strings to implememnting functions defined above
  #
  # All functions below implement the same calling interface:
  #
  # function(j, args, callback), where:
  # 
  # j        :  the JSON graph object to work on
  # args     :  an object of arguments to this command  
  # callback :  a function to call when the operation is complete
  #
  */


  commands = {
    'prelude1': '\n\
This program reads json format data files produced by the SEAStAR ref_select program.\n\
It implements a variety of commands for manipulating this data for assembly,\n\
visualization or output to a variety of file formats.\n',
    'prelude2': '\
For help with UNIX command line options, run the program with -h or --help\n\n\
All commands below accept parameters in the form: {"parm1":value1,"parm2":value2...}\n\
For examples and/or detailed help with specific commands, type:  HELP <command>\n\
',
    'spacer1': '===============================',
    'text1': 'File I/O commands\n',
    'LOAD': read_json,
    'DUMP': write_json,
    'TABLE': export_table,
    'FASTA': export_fasta,
    'DOT': export_dot,
    'spacer2': '\n===============================',
    'text2': 'Assembly pipeline commands (in this order)\n',
    'MST': maximal_spanning_tree,
    'SST': scaffold_spanning_tree,
    'text3': '   *** SST is an optional replacement for MST, useful for metagenomes',
    'text3a': '   *** or relatively short contigs',
    'PLUCK': remove_leaves,
    'PRUNE': cut_branches,
    'SLICE': check_connections,
    'text4': '   *** SLICE is optional, but recommended for metagenomes',
    'PUSH': add_ends,
    'INSERT': full_order,
    'SCAFF': scaffold,
    'CLUST': tetracalc,
    'SELCLUST': grab_clusts,
    'spacer3': '\n===============================',
    'text6': 'Assembly graph filter/edit utilities\n',
    'CCOMPS': calc_ccomps,
    'SELCC': grab_ccomps,
    'EDGFLT': filter_edges,
    'RELINK': relink,
    'SELND': grab_neighbors,
    'SCAFLNK': scaff_link,
    'PROBS': node_problems,
    'EDIT': perform_edits,
    'CUTND': cut_node,
    'spacer4': '\n===============================',
    'text7': 'Information and control\n',
    'GC': graph_stats,
    'GCC': graph_stats_cc,
    'STASH': push_stash,
    'UNSTASH': pop_stash,
    'SCRIPT': command_file,
    'HELP': output_help
  };

  /*   
  # This function gets called once the entire JSON data structure is available
  # It parses the commandline options and builds a callback_list that is used
  # to chain command calls together in an 'event driven' friendly manner.
  # It ends by calling the first command on the list via the call_next_cmd function.
  */


  process_commands = function(callback_list) {
    var call_next_cmd, json;
    json = {};
    call_next_cmd = function(err, j) {
      var cmd, cmd_args, cmd_func, _ref, _ref1;
      if (err) {
        console.error("ERROR: " + err.message + "\n");
        process.exit(1);
      }
      if (callback_list.length) {
        _ref = callback_list.shift(), cmd_func = _ref[0], cmd_args = _ref[1], cmd = _ref[2];
        if (!(((j != null ? j.nodes : void 0) != null) || cmd === 'LOAD' || cmd === 'SCRIPT' || cmd === 'UNSTASH' || cmd === 'HELP')) {
          console.error("ERROR: No data, ending command line processing.\n");
          process.exit(1);
        }
        if (cmd !== 'HELP') {
          if (j != null) {
            if ((_ref1 = j.processing) != null) {
              _ref1.push(["$", ss_version, cmd, clone_object(cmd_args)]);
            }
          }
        }
        console.warn("Executing " + cmd + " " + (JSON.stringify(cmd_args)));
        return cmd_func(j, cmd_args, call_next_cmd);
      }
    };
    return call_next_cmd(null, json);
  };

  /*
  # Handle commandline args
  */


  cmds = [];

  callback_list = [];

  if (process.argv.length < 3) {
    callback_list.push([commands['SCRIPT'], {}, 'SCRIPT']);
  } else if (process.argv[2].toUpperCase() === 'HELP') {
    if (process.argv[3] != null) {
      if (process.argv[3].match(/{.*}/)) {
        callback_list.push([commands['HELP'], JSON.parse(process.argv[3]), 'HELP']);
      } else {
        callback_list.push([
          commands['HELP'], {
            'topic': process.argv[3]
          }, 'HELP'
        ]);
      }
    } else {
      callback_list.push([commands['HELP'], {}, 'HELP']);
    }
  } else if (process.argv[2].match(/^-?-h(elp)?$/i)) {
    callback_list.push([
      commands['HELP'], {
        'cmd_line': true
      }, 'HELP'
    ]);
  } else {
    start_arg = 2;
    if (!((process.argv[2].toUpperCase() === 'LOAD') || (process.argv[2].toUpperCase() === 'SCRIPT'))) {
      if (process.argv[2].match(/^(-|(.+\.json(\.gz)?))$/)) {
        callback_list.push([
          commands['LOAD'], {
            'file': process.argv[2]
          }, 'LOAD'
        ]);
        start_arg++;
        if (process.argv[start_arg] == null) {
          process.argv[start_arg] = 'SCRIPT';
        }
      }
      if (process.argv[start_arg].match(/.+\.go(\.gz)?$/)) {
        callback_list.push([
          commands['SCRIPT'], {
            'file': process.argv[start_arg]
          }, 'SCRIPT'
        ]);
        start_arg++;
      }
    }
    prev_cmd = false;
    _ref = process.argv.slice(start_arg);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cmd = _ref[_i];
      if (prev_cmd && cmd.match(/{.*}/)) {
        try {
          callback_list.slice(-1)[0][1] = JSON.parse(cmd);
        } catch (err) {
          console.error("ERROR: Could not parse JSON arguments '" + cmd + "' to " + callback_list.slice(-1)[0][2] + " command");
          process.exit(1);
        }
        prev_cmd = false;
      } else if (typeof commands[cmd.toUpperCase()] === 'function') {
        cmd = cmd.toUpperCase();
        callback_list.push([commands[cmd], null, cmd]);
        prev_cmd = true;
      } else {
        console.error("ERROR: Invalid command line command: '" + cmd + "'\n");
        process.exit(1);
      }
    }
  }

  process_commands(callback_list);

}).call(this);
