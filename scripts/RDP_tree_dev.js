// Generated by CoffeeScript 1.6.1

/*
# -------------------------------------------------------------------------- #
# Center for Environmental Genomics
# Copyright (C) 2009-2012 University of Washington.
#
# Authors:
# Vaughn Iverson
# vsi@uw.edu
# -------------------------------------------------------------------------- #
# This file is part of SEAStAR.
#
# SEAStAR is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SEAStAR is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
# -------------------------------------------------------------------------- #
#
# This script reads in an RDP classifier taxonomic heirarchy file and converts
# it to a JSON tree formatted output file.
#
# Inputs: input modified RDP classifier output on stdin 
#         JSON formatted RDP heirarchy in the file named in RDP_heir_fn (or RDP_expand.json by default)
#         percent abundance below which a genus will be filtered out [0.10]
#
# Output:  output JSON formatted heirarchy to stdout

# Output file format:
# Each taxonomic unit in the RDP input file becomes a branch in the output JSON tree.
# Each branch has the following JSON structure:
#
# name : {
#      "name" : <name of this taxon>,
#      "pop" : <fraction of the sample>,
#      "cum" : <cumulative fraction of the sample>,
#      "num" : <number of sequences>,
#      "cnt" : <cumulative number of seqeunces>,
#      "conf" : <mean classifier p-value for sequences in this taxon>,
#      "level" : <numeric level in heirarchy>,
#      "length" : <branch length of this taxonomic level from parent>
#      "sub" : {<child nodes by name, or empty if a leaf>}
# }
*/


(function() {
  var RDP_heir_fn, build, fill_lineage_gap, filter, fs, i, level_after, level_name, level_name2num, level_num, levels, minperc, orig_lines, out_tree, parse_line, _i, _len, _ref, _ref1;

  fs = require('fs');

  RDP_heir_fn = (_ref = process.argv[2]) != null ? _ref : 'RDP_expand.json';

  minperc = parseFloat((_ref1 = process.argv[3]) != null ? _ref1 : 0.10);

  out_tree = JSON.parse(fs.readFileSync(RDP_heir_fn, 'utf8'));

  process.on('uncaughtException', function(err) {
    return console.log('Caught exception: ' + err);
  });

  process.stdin.setEncoding('utf8');

  process.stdin.resume();

  levels = [0, 1, 2, 3, 3.5, 4, 4.5, 5, 5.5, 5.75, 6];

  level_after = {};

  i = 0;

  while (i < levels.length - 1) {
    level_after[levels[i]] = levels[i + 1];
    i++;
  }

  level_name2num = {
    norank: 0,
    rootrank: 0,
    domain: 1,
    phylum: 2,
    "class": 3,
    subclass: 3.5,
    order: 4,
    suborder: 4.5,
    family: 5,
    subfamily: 5.5,
    supergenus: 5.75,
    genus: 6
  };

  for (level_num = _i = 0, _len = level_name2num.length; _i < _len; level_num = ++_i) {
    level_name = level_name2num[level_num];
    level_num2name[level_num] = level_name;
  }

  out_tree.walk = function(tree, prev_cnt, prev_cum) {
    var c, sub_tree, tmp, y, z, _results;
    if ((tree.sub != null) && Object.keys(tree.sub).length > 0) {
      tmp = (function() {
        var _ref2, _results;
        _ref2 = tree.sub;
        _results = [];
        for (y in _ref2) {
          z = _ref2[y];
          _results.push(z);
        }
        return _results;
      })();
      tmp.sort(function(b, a) {
        return a.pop - b.pop;
      });
      tree.sub = {};
      while (tmp.length) {
        c = tmp.shift();
        tree.sub[c.name] = c;
        c = tmp.pop();
        if (c) {
          tree.sub[c.name] = c;
        }
      }
    }
    _results = [];
    for (c in tree.sub) {
      if (tree.sub[c].num !== 0) {
        sub_tree = tree.sub[c];
        sub_tree.conf = sub_tree.conf / sub_tree.num;
        sub_tree.w_conf = sub_tree.w_conf / sub_tree.pop;
        sub_tree.cnt = prev_cnt;
        sub_tree.cum = prev_cum;
        out_tree.walk(sub_tree, prev_cnt, prev_cum);
        prev_cnt += sub_tree.num;
        _results.push(prev_cum += sub_tree.pop);
      } else {
        _results.push(delete tree.sub[c]);
      }
    }
    return _results;
  };

  filter = function(line_list, minperc) {
    var data, fields, genera, genus, line, retlines, _j, _len1;
    genera = {};
    for (_j = 0, _len1 = line_list.length; _j < _len1; _j++) {
      line = line_list[_j];
      fields = parse_line(line);
      genus = fields.tax_names.pop();
      if (genus in genera) {
        genera[genus].percent += fields.percent;
        genera[genus].lines.push(line);
      } else {
        genera[genus] = {
          percent: fields.percent,
          lines: [line]
        };
      }
    }
    retlines = [];
    for (genus in genera) {
      data = genera[genus];
      if (data.percent >= minperc) {
        Array.prototype.push.apply(retlines, data.lines);
      }
    }
    return retlines;
  };

  parse_line = function(line) {
    var fields, p, parts, _ref2;
    fields = {};
    parts = line.split('\t');
    _ref2 = parts.shift().split('_'), fields.sequence = _ref2[0], fields.percent = _ref2[1];
    fields.percent = parseFloat(fields.percent);
    parts.shift();
    fields.tax_names = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = parts.length; _j < _len1; _j += 3) {
        p = parts[_j];
        _results.push(p.replace(/"/g, '').trim());
      }
      return _results;
    })();
    parts.shift();
    fields.tax_levels = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = parts.length; _j < _len1; _j += 3) {
        p = parts[_j];
        _results.push(p.replace(/"/g, '').trim());
      }
      return _results;
    })();
    parts.shift();
    fields.tax_pvals = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = parts.length; _j < _len1; _j += 3) {
        p = parts[_j];
        _results.push(parseFloat(p));
      }
      return _results;
    })();
    return fields;
  };

  build = function(line) {
    var cur, fields, prev, start, tax_name, _j, _len1, _ref2;
    fields = parse_line(line);
    prev = null;
    cur = out_tree;
    _ref2 = fields.tax_names;
    for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
      tax_name = _ref2[i];
      prev = cur;
      start = prev;
      while (!(tax_name in cur.sub)) {
        cur = cur.sub["" + start.name + "_incertae_sedis"];
        prev = cur;
        cur.num++;
        cur.conf += fields.tax_pvals[i];
        cur.w_conf += fields.tax_pvals[i] * fields.percent;
        cur.pop += fields.percent;
      }
      cur = cur.sub[tax_name];
      fill_lineage_gap(prev, cur);
      cur.num++;
      cur.conf += fields.tax_pvals[i];
      cur.w_conf += fields.tax_pvals[i] * fields.percent;
      cur.pop += fields.percent;
    }
    return cur.sub[fields.sequence] = {
      pop: fields.percent,
      cum: 0.0,
      cnt: 0,
      num: 1,
      conf: fields.tax_pvals[fields.tax_pvals.length - 1],
      w_conf: fields.percent * fields.tax_pvals[fields.tax_pvals.length - 1],
      level: 7.0,
      length: 1.0,
      name: fields.sequence
    };
  };

  fill_lineage_gap = function(begin, end) {
    var cur, insert_name, level, save;
    if (((begin != null ? begin.level : void 0) == null) || ((end != null ? end.level : void 0) == null)) {
      return;
    }
    if (level_after[begin.level] === end.level) {
      return;
    }
    level = level_after[begin.level];
    cur = begin;
    while (level !== end.level) {
      insert_name = "" + begin.name + "_incertae_sedis";
      save = cur.sub;
      cur.sub = {};
      cur.sub[insert_name] = {
        name: insert_name,
        pop: begin.pop,
        cum: begin.cum,
        cnt: begin.cnt,
        num: begin.num,
        conf: begin.conf,
        w_conf: begin.w_conf,
        level: level,
        length: level - cur.level
      };
      level = level_after[level];
      cur = cur.sub[insert_name];
      cur.sub = save;
    }
    return end.length = end.level - cur.level;
  };

  orig_lines = [];

  process.stdin.on('data', (function() {
    var save;
    save = '';
    return function(c) {
      var lines;
      lines = c.split('\n');
      lines[0] = save + lines[0];
      save = lines.pop();
      return Array.prototype.push.apply(orig_lines, lines);
    };
  })());

  process.stdin.on('end', function() {
    var filtered_lines, _j, _len1;
    filtered_lines = filter(orig_lines, minperc);
    for (_j = 0, _len1 = filtered_lines.length; _j < _len1; _j++) {
      i = filtered_lines[_j];
      if (i) {
        build(i);
      }
    }
    out_tree.walk(out_tree, 0, 0.0);
    process.stdout.write(JSON.stringify(out_tree, null, 1) + "\n");
    return process.exit(0);
  });

}).call(this);
