// Generated by CoffeeScript 1.6.2
/*
# -------------------------------------------------------------------------- #
# Center for Environmental Genomics
# Copyright (C) 2012-2013 University of Washington.
#
# Authors:
# Vaughn Iverson
# vsi@uw.edu
# -------------------------------------------------------------------------- #
# This file is part of SEAStAR.
#
# SEAStAR is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# SEAStAR is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with SEAStAR.  If not, see <http:#www.gnu.org/licenses/>.
# -------------------------------------------------------------------------- #
*/


(function() {
  var cmds, fs, heal_fn, heal_m, heal_max, heal_n, heal_seq, heal_string, input, inputfn, output, overlap_m, overlap_max, overlap_n, p, parm, process_heal_fasta, process_scaffs, rc_tab, rev_comp, scaff_string, scaffs, ss_version, verbose, zlib,
    __slice = [].slice;

  if (!(process.version.split('.')[1] >= 10)) {
    console.error("ERROR: nodejs version v0.10.0 or greater required.");
    process.exit(1);
  }

  verbose = false;

  fs = require('fs');

  zlib = require('zlib');

  ss_version = "SS_BUILD_VERSION";

  scaff_string = '';

  heal_string = '';

  rc_tab = {
    'A': 'T',
    'T': 'A',
    'G': 'C',
    'C': 'G',
    'X': 'X',
    'M': 'K',
    'K': 'M',
    'R': 'Y',
    'Y': 'R',
    'W': 'S',
    'S': 'W',
    'V': 'B',
    'B': 'V',
    'H': 'D',
    'D': 'H',
    'N': 'N',
    '\n': '\n'
  };

  heal_seq = '';

  scaffs = [];

  rev_comp = function(st) {
    return st.split("").reverse().map(function(b) {
      return rc_tab[b];
    }).join("");
  };

  /*
  # Format the alternate assembly sequences used to "heal" gaps in the main scaffolds
  */


  process_heal_fasta = function(fasta) {
    var s;

    heal_seq = ((function() {
      var _i, _len, _ref, _results;

      _ref = fasta.split(">");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s.split("\n").slice(1).join("").toUpperCase());
      }
      return _results;
    })()).join("\n");
    return heal_seq = rev_comp(heal_seq) + "\n" + heal_seq;
  };

  /*
  # Process the scaffolds and write out the results.
  */


  process_scaffs = function(fasta) {
    var c, cf, cfmax, contig, cr, crmax, frame, i, j, l, m, match, max, n, name, ns, num_contigs, overlap, pad, pf, pfmax, pr, prev_contig, prmax, r, rc, rev_contig, rev_prev_contig, rp, s, scaf, scaf_ind, scaff_cnt, scaff_names, scaff_num, scaff_nums, scafout, seqs, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9, _results, _s, _t, _u, _v, _w, _x;

    num_contigs = [];
    scaff_cnt = 0;
    scaff_nums = {};
    scaff_names = [];
    _ref = fasta.split(">").slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      _ref1 = s.split(/\n| /), name = _ref1[0], scaff_string = _ref1[1], seqs = 3 <= _ref1.length ? __slice.call(_ref1, 2) : [];
      if (scaff_nums[scaff_string] == null) {
        scaff_nums[scaff_string] = scaff_cnt;
        scaff_names[scaff_cnt] = scaff_string;
        scaff_cnt++;
      }
      scaff_num = scaff_nums[scaff_string];
      if ((_ref2 = scaffs[scaff_num]) == null) {
        scaffs[scaff_num] = [];
      }
      if ((_ref3 = num_contigs[scaff_num]) == null) {
        num_contigs[scaff_num] = 0;
      }
      scaffs[scaff_num].push(seqs.join("").toUpperCase().match(/[ACGT]{10}.*[ACGT]{10}/)[0]);
      num_contigs[scaff_num]++;
    }
    if (heal_seq) {
      n = heal_n;
      m = heal_m;
      max = heal_max;
      for (scaf_ind = _j = 0, _len1 = scaffs.length; _j < _len1; scaf_ind = ++_j) {
        scaf = scaffs[scaf_ind];
        if (scaf) {
          for (y = _k = 0, _len2 = scaf.length; _k < _len2; y = ++_k) {
            contig = scaf[y];
            if (!(y)) {
              continue;
            }
            prev_contig = scaf[y - 1];
            l = prev_contig.length;
            r = "" + (prev_contig.substr(-(n + m), n)) + "([^\n]{1," + max + "})" + (contig.substr(m, n));
            if (match = heal_seq.match(r)) {
              overlap = match[1].toLowerCase();
              scaf[y] = prev_contig.substr(0, l - m) + overlap + contig.substr(m);
              delete scaf[y - 1];
              if (verbose) {
                console.warn("**** Found match! %d %d", scaf_ind, y);
                console.warn("%s", prev_contig.substr(-(n + m)));
                pad = '';
                for (x = _l = 1; 1 <= n ? _l <= n : _l >= n; x = 1 <= n ? ++_l : --_l) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, overlap);
                pad = '';
                for (x = _m = 1, _ref4 = n + overlap.length - m; 1 <= _ref4 ? _m <= _ref4 : _m >= _ref4; x = 1 <= _ref4 ? ++_m : --_m) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, contig.substr(0, m + n));
              }
            }
          }
        }
      }
    }
    for (x = _n = 0, _len3 = scaffs.length; _n < _len3; x = ++_n) {
      scaf = scaffs[x];
      if (scaf) {
        scaffs[x] = (function() {
          var _len4, _o, _results;

          _results = [];
          for (_o = 0, _len4 = scaf.length; _o < _len4; _o++) {
            contig = scaf[_o];
            if (contig != null) {
              _results.push(contig);
            }
          }
          return _results;
        })();
      }
    }
    n = overlap_n;
    m = overlap_m;
    max = overlap_max;
    for (x = _o = 0, _len4 = scaffs.length; _o < _len4; x = ++_o) {
      scaf = scaffs[x];
      if (scaf) {
        for (y = _p = 0, _len5 = scaf.length; _p < _len5; y = ++_p) {
          contig = scaf[y];
          if (!(y)) {
            continue;
          }
          prev_contig = scaf[y - 1];
          l = prev_contig.length;
          for (i = _q = max; max <= n ? _q <= n : _q >= n; i = max <= n ? ++_q : --_q) {
            c = 0;
            for (j = _r = 0; 0 <= i ? _r < i : _r > i; j = 0 <= i ? ++_r : --_r) {
              if (prev_contig.substr(l - i + j, 1) === contig.substr(j, 1)) {
                c++;
              } else if ((c < n) || (c < i - (2 * m))) {
                c = 0;
              } else {
                break;
              }
            }
            if ((c >= n) && (c >= i - (2 * m))) {
              overlap = prev_contig.substr(l - i + (j - c), c).toLowerCase();
              scaf[y] = prev_contig.substr(0, l - i + (j - c)) + overlap + contig.substr(c + (j - c));
              delete scaf[y - 1];
              if (verbose) {
                console.warn("**** Found match! %d %d %d %d %d", x, y, i, j, c);
                console.warn("%s", prev_contig.substr(l - max + 1));
                pad = '';
                for (x = _s = 1, _ref5 = max - i + (j - c); 1 <= _ref5 ? _s < _ref5 : _s > _ref5; x = 1 <= _ref5 ? ++_s : --_s) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, overlap);
                pad = '';
                for (x = _t = 1, _ref6 = max - i; 1 <= _ref6 ? _t < _ref6 : _t > _ref6; x = 1 <= _ref6 ? ++_t : --_t) {
                  pad = pad + " ";
                }
                console.warn("%s%s", pad, contig.substr(0, max));
              }
              break;
            } else {
              c = 0;
            }
          }
        }
      }
    }
    for (x = _u = 0, _len6 = scaffs.length; _u < _len6; x = ++_u) {
      scaf = scaffs[x];
      if (scaf) {
        scaffs[x] = (function() {
          var _len7, _results, _v;

          _results = [];
          for (_v = 0, _len7 = scaf.length; _v < _len7; _v++) {
            contig = scaf[_v];
            if (contig != null) {
              _results.push(contig);
            }
          }
          return _results;
        })();
      }
    }
    rp = /(?:(?:[^T]..)|(?:T(?:(?:[^AG].)|(?:G[^A])|(?:A[^GA]))))+$/;
    rc = /^(?:(?:[^T]..)|(?:T(?:(?:[^AG].)|(?:G[^A])|(?:A[^GA]))))+/;
    ns = ['', 'N', 'NN'];
    _results = [];
    for (x = _v = 0, _len7 = scaffs.length; _v < _len7; x = ++_v) {
      scaf = scaffs[x];
      if (!(scaf)) {
        continue;
      }
      scafout = scaf[0];
      prev_contig = scaf[0];
      rev_prev_contig = rev_comp(prev_contig);
      for (y = _w = 0, _len8 = scaf.length; _w < _len8; y = ++_w) {
        contig = scaf[y];
        if (!(y)) {
          continue;
        }
        rev_contig = rev_comp(contig);
        pfmax = [-1, -1];
        cfmax = [-1, -1];
        prmax = [-1, -1];
        crmax = [-1, -1];
        for (n = _x = 0; _x <= 2; n = ++_x) {
          pf = (_ref7 = (_ref8 = (prev_contig + ns[n]).match(rp)) != null ? _ref8[0].length : void 0) != null ? _ref7 : 0;
          if (pf > pfmax[1]) {
            pfmax = [n, pf];
          }
          cf = (_ref9 = (_ref10 = (ns[n] + contig).match(rc)) != null ? _ref10[0].length : void 0) != null ? _ref9 : 0;
          if (cf > cfmax[1]) {
            cfmax = [n, cf];
          }
          pr = (_ref11 = (_ref12 = (ns[n] + rev_prev_contig).match(rc)) != null ? _ref12[0].length : void 0) != null ? _ref11 : 0;
          if (pr > prmax[1]) {
            prmax = [n, pr];
          }
          cr = (_ref13 = (_ref14 = (rev_contig + ns[n]).match(rp)) != null ? _ref14[0].length : void 0) != null ? _ref13 : 0;
          if (cr > crmax[1]) {
            crmax = [n, cr];
          }
        }
        if (pfmax[1] + cfmax[1] > prmax[1] + crmax[1]) {
          frame = (pfmax[0] + cfmax[0]) % 3;
        } else {
          frame = (prmax[0] + crmax[0]) % 3;
        }
        scafout = scafout + "nnnnnnnnnnnnnnn" + ns[frame] + contig;
        prev_contig = contig;
        rev_prev_contig = rev_contig;
      }
      process.stdout.write(">" + scaff_names[x] + "\n");
      process.stdout.write(scafout);
      _results.push(process.stdout.write("\n"));
    }
    return _results;
  };

  /*
  # Handle command args and process input files
  */


  output = process.stdout;

  cmds = [];

  heal_fn = null;

  heal_n = 29;

  heal_m = 5;

  heal_max = 500;

  overlap_n = 6;

  overlap_m = 0;

  overlap_max = 35;

  if (process.argv.length < 3) {
    console.error("No inputs provided, use --help for assistance.");
    process.exit(1);
  }

  process.argv.shift();

  process.argv.shift();

  while (process.argv[0].slice(0, 2) === '--' || process.argv[0] === '-h') {
    p = process.argv.shift();
    parm = p.split('=');
    if (!((p[1] != null) || p === '-h' || p === '--help')) {
      console.error("Invalid parameter: " + p + ".  No integer value included.");
      process.exit(1);
    }
    switch (parm[0]) {
      case '--help':
      case '-h':
        console.warn("\nUsage: seq_scaffold [options] input.fna");
        console.warn('[options] : [--overlap=<n>] [--trim=<n>] [--max=<n>] [--heal=<heafile.fna>] [--heal_overlap=<n>] [--heal_trim=<n>] [--heal_max=<n>]\n');
        console.warn("--overlap=<n> : Minimum number of bases of overlap required to join contigs. Default: " + overlap_n);
        console.warn("--max=<n> : Maximum number of bases of overlap to look for. Default: " + overlap_max);
        console.warn("--trim=<n> : Maximum number of non-ambiguous bases to try trimming from contig ends when looking for overlap. Default: " + overlap_m);
        console.warn("--heal=<healfile.fna> : Use alternatively assembled contigs in the references FASTA file to try to \"heal\" gaps. Default: No Healing");
        console.warn("--heal_overlap=<n> : Minimum number of bases of overlap required to join contigs. Default: " + heal_n);
        console.warn("--heal_max=<n> : Maximum number of bases of gap to try to heal. Default: " + heal_max);
        console.warn("--heal_trim=<n> : Maximum number of non-ambiguous bases to try trimming from contig ends during healing. Default: " + heal_m);
        console.warn("--verbose : Output diagnostic messages to stderr. Default: " + verbose + "\n");
        console.warn("SEASTAR Version: " + ss_version + "\n");
        process.exit(1);
        break;
      case '--heal':
        heal_fn = parm[1];
        break;
      case '--heal_overlap':
        heal_n = Number(parm[1]);
        break;
      case '--heal_trim':
        heal_m = Number(parm[1]);
        break;
      case '--heal_max':
        heal_max = Number(parm[1]);
        break;
      case '--overlap':
        overlap_n = Number(parm[1]);
        break;
      case '--trim':
        overlap_m = Number(parm[1]);
        break;
      case '--max':
        overlap_max = Number(parm[1]);
        break;
      case '--verbose':
        verbose = true;
        break;
      default:
        console.error("Unknown parameter: " + p);
        process.exit(1);
    }
  }

  inputfn = process.argv[0];

  if (inputfn === '-') {
    input = process.stdin;
    input.resume();
  } else if (inputfn.slice(-3) === '.gz') {
    input = fs.createReadStream(inputfn).pipe(zlib.createGunzip());
  } else {
    input = fs.createReadStream(inputfn);
  }

  input.on('data', function(data) {
    return scaff_string = scaff_string.concat(data);
  }).on('end', function() {
    if (heal_fn) {
      if (heal_fn === '-') {
        input = process.stdin;
        input.resume();
      } else if (heal_fn.slice(-3) === '.gz') {
        input = fs.createReadStream(heal_fn).pipe(zlib.createGunzip());
      } else {
        input = fs.createReadStream(heal_fn);
      }
      return input.on('data', function(data) {
        return heal_string = heal_string.concat(data);
      }).on('end', function() {
        process_heal_fasta(heal_string);
        process_scaffs(scaff_string);
        return process.stdout.end();
      });
    } else {
      return process_scaffs(scaff_string);
    }
  });

}).call(this);
